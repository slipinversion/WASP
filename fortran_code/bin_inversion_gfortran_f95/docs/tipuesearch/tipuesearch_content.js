var tipuesearch = {"pages":[{"loc":"index.html","text":"Kinematic modelling This code allows to solve a nonlinear finite fault inverse problem using simmulated annealing. The inversion is performed in wavelet domain. This version of the code is written in Fortran95, and has been parallelized using OPENMP. Note This code is modified from the original, written by Dr. Chen-Ji. We claim no intellectual property whatsoever over this code. Bug We have observed, this code doesn't work well when compiled with ifort and OPENMP. In order to compile with ifort, we suggest removing the OPENMP compilation options.","title":" Kinematic modelling ","tags":"home"},{"loc":"sourcefile/rise_time.f95.html","text":"Contents Modules rise_time Source Code rise_time.f95 Source Code module rise_time use constants , only : inptd , nnsta , mmsou , pi , twopi use get_stations_data , only : dt_channel , lnpt use model_parameters , only : ta0 , dta , msou implicit none complex , allocatable :: source (:, :, :, :) integer , parameter , private :: double = kind ( 1 d0 ) contains subroutine realtr ( xr , xi , n ) implicit none real :: xr ( * ), xi ( * ) integer :: n integer :: i , i1 , i2 , lb , lh lh = 2 ** ( n - 1 ) lb = lh - 1 lh = lh + 1 do i = 1 , lb i1 = lh + i i2 = lh - i xr ( i1 ) = xr ( i2 ) xi ( i1 ) = - xi ( i2 ) end do xi ( lh ) = 0.0 end subroutine realtr ! subroutine fft ( xr , xi , n , sn ) !! !!   Fast Fourier transform. !! implicit none real :: xr ( * ), xi ( * ), sn integer :: m ( 25 ), n real :: flx , holdi , holdr , qi , qr , v , wki , wkr integer :: i , ib , ist , j , j1 , jh , k , l , lb , lbh , lx , nb lx = 2 ** n flx = lx do i = 1 , n m ( i ) = 2 ** ( n - i ) end do do l = 1 , n nb = 2 ** ( l - 1 ) lb = lx / nb lbh = lb / 2 k = 0 do ib = 1 , nb v = sn * twopi * k / flx wkr = cos ( v ) wki = sin ( v ) ist = lb * ( ib - 1 ) do i = 1 , lbh j = ist + i jh = j + lbh qr = xr ( jh ) * wkr - xi ( jh ) * wki qi = xr ( jh ) * wki + xi ( jh ) * wkr xr ( jh ) = xr ( j ) - qr xi ( jh ) = xi ( j ) - qi xr ( j ) = xr ( j ) + qr xi ( j ) = xi ( j ) + qi end do do i = 2 , n if ( k . LT . m ( i )) exit k = k - m ( i ) end do k = k + m ( i ) end do end do k = 0 do j = 1 , lx if ( k . lt . j ) goto 7 holdr = xr ( j ) holdi = xi ( j ) j1 = k + 1 xr ( j ) = xr ( j1 ) xi ( j ) = xi ( j1 ) xr ( j1 ) = holdr xi ( j1 ) = holdi 7 do i = 1 , n if ( k . lt . m ( i )) exit k = k - m ( i ) end do k = k + m ( i ) end do if ( sn . ge . 0. ) then do i = 1 , lx xr ( i ) = xr ( i ) / flx xi ( i ) = xi ( i ) / flx end do end if end subroutine fft subroutine fourier_asym_cosine ( omega , t1 , t2 , source ) !! !!   Analitic fourier transform of asymmetric cosine !! implicit none complex source real omega , t1 , t2 complex * 16 first , second , third , fourth , fifth , z0 z0 = cmplx ( 1.d0 , 0.d0 , double ) if ( omega . lt . 1.e-6 ) then first = cmplx ( 0.d0 , - t1 - t2 , double ) else first = cmplx ( 0.d0 , - 2.d0 * pi * omega * ( t1 + t2 ), double ) first = ( exp ( first ) - z0 ) * cmplx ( 0.5d0 / pi / omega , 0.d0 , double ) end if second = cmplx ( 0.d0 , - pi * ( 2.d0 * omega * t1 + 1.d0 ), double ) second = ( exp ( second ) - z0 ) * cmplx ( 1.d0 / pi / ( 2.d0 * omega + 1.d0 / t1 ), 0.d0 , double ) if ( abs ( 2 * t1 * omega - 1 ) . lt . 1.e-6 ) then third = cmplx ( 0.d0 , t1 , double ) else third = cmplx ( 0.d0 , pi * ( 1.d0 - 2.d0 * omega * t1 ), double ) third = ( exp ( third ) - z0 ) * cmplx ( 1.d0 / pi / ( 1.d0 / t1 - 2.d0 * omega ), 0.d0 , double ) end if if ( abs ( 2 * t2 * omega - 1 ) . lt . 1.e-6 ) then fourth = cmplx ( 0.d0 , t2 , double ) else fourth = cmplx ( 0.d0 , pi * ( 1.d0 - 2.d0 * omega * t2 ), double ) fourth = ( exp ( fourth ) - z0 ) * cmplx ( 1.d0 / pi / ( 1.d0 / t2 - 2.d0 * omega ), 0.d0 , double ) end if fifth = cmplx ( 0.d0 , - pi * ( 2.d0 * omega * t2 + 1.d0 ), double ) fifth = ( exp ( fifth ) - z0 ) * cmplx ( 1.d0 / pi / ( 2.d0 * omega + 1.d0 / t2 ), 0.d0 , double ) source = cmplx ( 0. , - 2. * pi * omega * t1 ) source = exp ( source ) * ( fifth - fourth ) source = source + third - second source = source * cmplx ( 0.5 , 0. ) + first source = source * cmplx ( 0. , 1. / ( t1 + t2 )) end subroutine fourier_asym_cosine subroutine get_source_fun () !! !!  We load to memory, the Fourier transform of rise time function !! implicit none real :: df , dt , t1 , t2 integer :: i , ir , isl , isr , jf allocate ( source ( inptd , nnsta , mmsou , mmsou )) jf = 2 ** ( lnpt - 1 ) + 1 do ir = 1 , nnsta dt = dt_channel ( ir ) if ( dt . lt . 1.e-4 ) cycle df = 1.0 / ( 2 ** lnpt ) / dt if ( abs ( dt - 6 0.0 ) . gt . 1.e-4 ) then do isr = 1 , msou do isl = 1 , msou t1 = ta0 + ( isl - 1 ) * dta t2 = ta0 + ( isr - 1 ) * dta t1 = max ( dt , t1 ) t2 = max ( dt , t2 ) do i = 1 , jf call fourier_asym_cosine (( i - 1 ) * df , t1 , t2 , source ( i , ir , isl , isr )) end do end do end do else do isr = 1 , msou do isl = 1 , msou do i = 1 , jf source ( i , ir , isl , isr ) = cmplx ( 1.0 , 0.0 ) end do end do end do end if end do end subroutine get_source_fun subroutine deallocate_source () deallocate ( source ) end subroutine deallocate_source end module rise_time","title":"rise_time.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/retrieve_surf_gf.f95.html","text":"Contents Modules retrieve_surf_gf Source Code retrieve_surf_gf.f95 Source Code module retrieve_surf_gf use constants , only : nny , ndis , nt , inptd implicit none integer , private :: nblock2 , nx , nz , nfmax integer :: npt_bank , dt_bank real , private :: dep_max , dep_min , dep_step , dist_max , dist_min , d_step real , private :: grid_depth ( 50 ), grid_dist ( 1601 ) complex , private :: green_bank ( inptd , 10 , 1601 , 50 ) contains subroutine get_surf_gf_data ( gf_file , gf_bank ) implicit none character ( len = 100 ), intent ( in ) :: gf_file character ( len = 100 ), intent ( out ) :: gf_bank integer :: int2 , int3 , int4 open ( 1 , file = gf_file ) read ( 1 , * ) npt_bank , dt_bank , int2 , int3 , int4 , nfmax , nblock2 read ( 1 , * ) dep_min , dep_step , nz read ( 1 , * ) dist_min , d_step , nx read ( 1 , '(a)' ) gf_bank write ( * , * ) 'GF bank name' write ( * , * ) gf_bank close ( 1 ) dep_max = dep_min + ( nz - 1 ) * dep_step dist_max = dist_min + ( nx - 1 ) * d_step end subroutine get_surf_gf_data subroutine get_surf_gf ( gf_bank , d_min , d_max , z_min , z_max ) !! !!  Load to memory GF bank, from a specified location. !! implicit none character ( len = 100 ) :: gf_bank real :: d_min , d_max , z_min , z_max integer :: nx_b , nx_e , nz_b , nz_e , ixx , izz integer :: index_rec real :: fault_bounds ( 2 , 2 ) real :: dt_c , t0 , dep , dis0 integer :: iz , iz0 , k , k0 , npt_c , ntc , n_com , nptf call grid_properties () fault_bounds ( 1 , 1 ) = d_min fault_bounds ( 2 , 1 ) = d_max fault_bounds ( 1 , 2 ) = z_min fault_bounds ( 2 , 2 ) = z_max call get_subgrid_bounds ( fault_bounds , nx_b , nx_e , nz_b , nz_e ) open ( 50 , file = gf_bank , status = 'old' , access = 'direct' , recl = nblock2 ) ! open green functions bank index_rec = 0 write ( * , * ) nz_b , nz_e , nx_b , nx_e do iz = nz_b , nz_e do k = nx_b , nx_e index_rec = ( iz - 1 ) * nx + k ixx = k - nx_b + 1 izz = iz - nz_b + 1 read ( 50 , rec = index_rec ) iz0 , k0 , dis0 , t0 , dep , dt_c , npt_c , nptf , & & (( green_bank ( ntc , n_com , ixx , izz ), ntc = 1 , nptf ), n_com = 1 , 10 ) ! ! anticipate potential errors ! if ( abs ( dis0 - grid_dist ( k )) . gt . 1e-4 ) then write ( * , * ) \"Error: distance to source should be \" , grid_dist ( k ), \" but real distance is \" , dis0 write ( * , * ) \"Check size of gf bank\" write ( * , * ) \"Check size of 'green_bank' variable\" write ( * , * ) \"Check given range of distances and depths agrees with size of gf bank\" write ( * , * ) \"You may need to recompute GF bank\" stop end if if ( abs ( dep - grid_depth ( iz )) . gt . 1e-4 ) then write ( * , * ) \"Error: depth of source should be \" , grid_depth ( iz ), \" but real depth is \" , dep write ( * , * ) \"Check size of gf bank\" write ( * , * ) \"Check size of 'green_bank' variable\" write ( * , * ) \"Check given range of distances and depths agrees with size of gf bank\" write ( * , * ) \"You may need to recompute GF bank\" stop end if end do end do end subroutine get_surf_gf function interp_gf ( distance , depth , d_min , d_max , zu_min , zu_max ) result ( green_out ) !! !!  Get GF at a given location and depth, as the average of the 4 closest !!  GF in the distance-depth grid. !! implicit none real ( 8 ) :: distance real :: depth , zu_min , zu_max real :: fault_bounds ( 2 , 2 ) complex :: green_out ( inptd , 10 ) real :: d_min , d_max , d_min2 , d_max2 , z_max , z_min complex :: green_up_left , green_down_left , green_up_right , green_down_right real :: ratio_x , ratio_z , dep_use , subgrid_dist ( 1601 ), subgrid_depth ( 20 ) integer :: k , k_down , k_left , k_up , k_right , n , ncom integer :: nx_b , nx_e , nz_b , nz_e fault_bounds ( 1 , 1 ) = d_min fault_bounds ( 2 , 1 ) = d_max fault_bounds ( 1 , 2 ) = zu_min fault_bounds ( 2 , 2 ) = zu_max call get_subgrid_bounds ( fault_bounds , nx_b , nx_e , nz_b , nz_e ) call get_subgrid ( fault_bounds , subgrid_dist , subgrid_depth ) dep_use = depth green_out (:, :) = 0.0 d_min2 = subgrid_dist ( 1 ) d_max2 = subgrid_dist ( nx_e - nx_b + 1 ) z_min = subgrid_depth ( 1 ) z_max = subgrid_depth ( nz_e - nz_b + 1 ) if ( distance . gt . d_max2 . or . distance . lt . d_min2 ) then write ( * , * ) \"ooh The input distance is over the x_boundary\" write ( * , * ) \"green function is set to zero\" write ( * , * ) distance , d_max , d_min return end if dep_use = max ( dep_use , z_min ) dep_use = min ( dep_use , z_max ) if ( depth . gt . z_max . or . depth . lt . z_min ) then write ( * , * ) \"The input depth is outside vertical boundary\" write ( * , * ) \"use the z_max or zmin instead\" , depth , z_max , z_min end if k_left = 1 do k = 1 , nx_e - nx_b + 1 if ( distance . lt . subgrid_dist ( k )) then k_left = k - 1 exit end if end do k_right = k_left + 1 k_up = 1 do k = 1 , nz_e - nz_b + 1 if ( dep_use . lt . subgrid_depth ( k )) then k_up = k - 1 exit end if end do k_up = min ( k_up , nz_e - nz_b ) k_down = k_up + 1 !   write(*,*) distance, k_left, k_right !   write(*,*) depth, k_up, k_down ratio_x = ( distance - subgrid_dist ( k_left )) / d_step ratio_z = ( dep_use - subgrid_depth ( k_up )) / dep_step do ncom = 1 , 10 do n = 1 , inptd green_up_left = green_bank ( n , ncom , k_left , k_up ) green_up_right = green_bank ( n , ncom , k_right , k_up ) green_down_left = green_bank ( n , ncom , k_left , k_down ) green_down_right = green_bank ( n , ncom , k_right , k_down ) green_out ( n , ncom ) = ( 1 - ratio_z ) * ( 1 - ratio_x ) * green_up_left & & + ratio_z * ( 1 - ratio_x ) * green_down_left & & + ( 1 - ratio_z ) * ratio_x * green_up_right & & + ratio_x * ratio_z * green_down_right end do end do end function interp_gf subroutine grid_properties () implicit none integer :: k do k = 1 , nx grid_dist ( k ) = dist_min + ( k - 1 ) * d_step end do do k = 1 , nz grid_depth ( k ) = dep_min + ( k - 1 ) * dep_step end do end subroutine grid_properties subroutine get_subgrid_bounds ( fault_bounds , nx_b , nx_e , nz_b , nz_e ) implicit none real , intent ( in ) :: fault_bounds ( 2 , 2 ) integer , intent ( out ) :: nx_b , nx_e , nz_b , nz_e real :: d_min , d_max , zu_min , zu_max d_min = fault_bounds ( 1 , 1 ) d_max = fault_bounds ( 2 , 1 ) zu_min = fault_bounds ( 1 , 2 ) zu_max = fault_bounds ( 2 , 2 ) if ( dist_max . lt . d_max ) then d_max = dist_max write ( * , * ) \"required maximum distance is large the Green\" write ( * , * ) \"Function range, use the dist_max instead\" end if nx_b = int (( d_min - dist_min ) / d_step ) if ( nx_b . le . 0 ) nx_b = 1 nx_e = int (( d_max - dist_min ) / d_step + 0.5 ) + 2 if ( nx_e . gt . nx ) nx_e = nx nz_b = int (( zu_min - dep_min ) / dep_step ) if ( nz_b . le . 0 ) nz_b = 1 nz_e = int (( zu_max - dep_min ) / dep_step + 0.5 ) + 2 if ( nz_e . gt . nz ) nz_e = nz end subroutine get_subgrid_bounds subroutine get_subgrid ( fault_bounds , subgrid_dist , subgrid_depth ) implicit none real , intent ( in ) :: fault_bounds ( 2 , 2 ) real , intent ( out ) :: subgrid_depth ( 20 ), subgrid_dist ( 1601 ) integer :: k , nx_b , nx_e , nz_b , nz_e call get_subgrid_bounds ( fault_bounds , nx_b , nx_e , nz_b , nz_e ) do k = nz_b , nz_e subgrid_depth ( k - nz_b + 1 ) = grid_depth ( k ) end do do k = nx_b , nx_e subgrid_dist ( k - nx_b + 1 ) = grid_dist ( k ) end do end subroutine get_subgrid end module retrieve_surf_gf","title":"retrieve_surf_gf.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/constants.f95.html","text":"Contents Modules constants Source Code constants.f95 Source Code module constants implicit none integer , parameter :: nnpy = 25 , nnpx = 25 , nnxs = 50 , nnys = 20 , mmsou = 25 integer , parameter :: mpx = nnpx * nnxs , mpy = nnpy * nnys , nnxy = nnxs * nnys integer , parameter :: nnpxy = nnpx * nnpy , l2 = 10 integer , parameter :: npth = 2 ** l2 , inptd = 2 * npth , n_data = 10000 integer , parameter :: nnsta = 300 integer , parameter :: max_seg = 5 , nnxy_m = 660 , nt1 = max_seg * nnxy_m integer , parameter :: npuse = 513 , block_stg = npuse * 130 integer , parameter :: block_far = 256 * 1024 , ltde = 320000 real * 8 , parameter :: pi = 4.d0 * atan ( 1.d0 ), twopi = 2.d0 * pi real * 8 , parameter :: dpi = pi / 18 0.d0 real , parameter :: pi_0 = 4.0 * atan ( 1.0 ), twopi_0 = 2.0 * pi_0 , dpi_0 = pi_0 / 18 0.0 !       maximum layer, distances, and time samples !       maximum size of green's function (nnx*nny) integer , parameter :: nlay = 50 , ndis = 1100 , nt = 1025 integer , parameter :: nny = 310 end module constants","title":"constants.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/wavelets.f95.html","text":"Contents Modules wavelets Source Code wavelets.f95 Source Code module wavelets use constants , only : pi , twopi , inptd , nnsta use wavelet_param , only : jmin , jmax , lnpt , nlen implicit none complex :: rwt1 ( inptd , 12 ), rwt2 ( inptd , 12 ), c1 , c2 integer :: kkk ( 4200 , 15 ) real :: cos_fft ( 4200 , 15 ), sin_fft ( 4200 , 15 ) contains subroutine wavelet_obs ( cr , cz , u ) !! !!   Compute wavelet transform. Input data is in time domain !! implicit none !       ******* Explaination ******** !       In order to normalized the amplitude, we move the coeffficient !       sqrt(T/kmax) !                                       Jichen 1997, 1, 20 ! ! we split between this routine and wavelet_syn routine to hopefully reduce ! computation time ! real :: cr ( inptd ), cz ( inptd ), u ( inptd ) integer lcc , kmax , is , j , k , i complex fre ( inptd ) complex cc ! do i = 1 , nlen cr ( i ) = u ( i ) cz ( i ) = 0.0 end do call cfft ( cr , cz , lnpt ) call realtr ( cr , cz , lnpt ) do j = 1 , nlen fre ( j ) = cmplx ( cr ( j ), cz ( j )) cr ( j ) = 0.0 cz ( j ) = 0.0 u ( j ) = 0.0 end do ! ! c1 = wave(pi2, 2), c2 = wave(pi, 2). ! u ( 1 ) = 2.0 * real ( fre ( 2 ) * c1 ) u ( 2 ) = 2.0 * real ( fre ( 2 ) * c2 + fre ( 3 ) * c1 ) u ( 3 ) = 2.0 * real ( - fre ( 2 ) * c2 + fre ( 3 ) * c1 ) j = max ( 3 , jmin ) - 1 kmax = 2 ** ( j - 1 ) do j = max ( 3 , jmin ), jmax kmax = 2 * kmax do is = 1 , kmax cc = fre ( is ) * rwt1 ( is , j ) + fre ( is + kmax ) * rwt2 ( is , j ) cr ( is ) = real ( cc ) cz ( is ) = aimag ( cc ) end do lcc = j - 1 call cifft ( cr , cz , Lcc ) do k = 1 , kmax u ( kmax + k - 1 ) = 2.0 * cr ( k ) end do end do end subroutine wavelet_obs pure subroutine wavelet_syn ( cr , cz , u ) !! !!   Compute wavelet transform. Input data is in frequency domain !! implicit none !       ******* Explaination ******** !       In order to normalized the amplitude, we move the coeffficient !       sqrt(T/kmax) !                         Jichen 1997, 1, 20 real , intent ( out ) :: u ( inptd ) real , intent ( inout ) :: cr ( inptd ), cz ( inptd ) integer lcc , kmax , is , lb , i , i1 , i2 , j , k complex fre ( inptd ) complex cc lcc = 2 ** ( lnpt - 1 ) lb = lcc - 1 lcc = lcc + 1 do i = 1 , lb i1 = lcc + i i2 = lcc - i cr ( i1 ) = cr ( i2 ) cz ( i1 ) = - cz ( i2 ) end do cz ( lcc ) = 0.0 do j = 1 , nlen fre ( j ) = cmplx ( cr ( j ) / nlen , cz ( j ) / nlen ) end do ! ! c1 = wave(pi2, 2), c2 = wave(pi, 2). ! u ( 1 ) = 2.0 * real ( fre ( 2 ) * c1 ) u ( 2 ) = 2.0 * real ( fre ( 2 ) * c2 + fre ( 3 ) * c1 ) u ( 3 ) = 2.0 * real ( - fre ( 2 ) * c2 + fre ( 3 ) * c1 ) j = max ( 3 , jmin ) - 1 kmax = 2 ** ( j - 1 ) do j = max ( 3 , jmin ), jmax kmax = 2 * kmax ! ** (j - 1)   ! 2*kmax do is = 1 , kmax cc = fre ( is ) * rwt1 ( is , j ) + fre ( is + kmax ) * rwt2 ( is , j ) cr ( is ) = real ( cc ) cz ( is ) = aimag ( cc ) end do lcc = j - 1 call cifft ( cr , cz , Lcc ) do k = 1 , kmax u ( kmax + k - 1 ) = 2.0 * cr ( k ) end do end do end subroutine wavelet_syn pure subroutine cfft ( xr , xi , n ) !! !!   Fast Fourier transform !! implicit none integer , intent ( in ) :: n real , intent ( inout ) :: xr ( * ), xi ( * ) integer k , i , ib , nb , lx , l , lb , lbh , ist , jh , j1 , j real wkr , wki , qr , qi , holdr , holdi , flx ! ! we store in memory the values of 'k', so as to not need to initialize them time and again. ! LX = 2 ** N FLX = real ( LX ) DO L = 1 , N NB = 2 ** ( L - 1 ) LB = LX / NB LBH = LB / 2 DO IB = 1 , NB ! 2 ** (l-1) operaciones WKR = cos_fft ( ib , n ) WKI = - sin_fft ( ib , n ) IST = LB * ( IB - 1 ) DO J = IST + 1 , IST + LBH JH = J + LBH QR = XR ( JH ) * WKR - XI ( JH ) * WKI QI = XR ( JH ) * WKI + XI ( JH ) * WKR XR ( JH ) = ( XR ( J ) - QR ) XI ( JH ) = ( XI ( J ) - QI ) XR ( J ) = ( XR ( J ) + QR ) XI ( J ) = ( XI ( J ) + QI ) end do end do end do K = 0 DO J = 1 , LX K = KKK ( J , N ) IF ( K . LT . J ) cycle HOLDR = XR ( J ) HOLDI = XI ( J ) J1 = K + 1 XR ( J ) = XR ( J1 ) XI ( J ) = XI ( J1 ) XR ( J1 ) = HOLDR XI ( J1 ) = HOLDI end do DO I = 1 , LX XR ( I ) = XR ( I ) / FLX XI ( I ) = XI ( I ) / FLX ENDDO END subroutine cfft pure subroutine cifft ( xr , xi , n ) !! !!   Inverse Fast Fourier transform !! implicit none integer , intent ( in ) :: n real , intent ( inout ) :: xr ( * ), xi ( * ) integer k , ib , nb , lx , l , lb , lbh , ist , jh , j1 , j real wkr , wki , qr , qi , holdr LX = 2 ** N DO L = 1 , N NB = 2 ** ( L - 1 ) LB = LX / NB LBH = LB / 2 DO IB = 1 , NB ! 2 ** (l-1) operaciones WKR = cos_fft ( ib , n ) WKI = sin_fft ( ib , n ) IST = LB * ( IB - 1 ) DO J = IST + 1 , IST + LBH JH = J + LBH QR = XR ( JH ) * WKR - XI ( JH ) * WKI QI = XR ( JH ) * WKI + XI ( JH ) * WKR XR ( JH ) = XR ( J ) - QR XI ( JH ) = XI ( J ) - QI XR ( J ) = XR ( J ) + QR XI ( J ) = XI ( J ) + QI ENDDO ENDDO ENDDO K = 0 DO J = 1 , LX K = KKK ( j , N ) IF ( K . LT . J ) cycle HOLDR = XR ( J ) J1 = K + 1 XR ( J ) = XR ( J1 ) XR ( J1 ) = HOLDR end do end subroutine cifft subroutine fourier_coefs () implicit none !! !!  We load into memory certain values of sine and cosine, frequently used in computing the !!  Fast Fourier Transform. !! integer i , n , nb , nnb , ib , k , kk ( 4200 , 15 ) real * 8 :: omega do n = 2 , 12 k = 0 nb = 2 ** ( n - 1 ) nnb = 2 ** n do ib = 1 , nb kk ( ib , n ) = k omega = twopi * k / nnb cos_fft ( ib , n ) = cos ( omega ) sin_fft ( ib , n ) = sin ( omega ) do i = 2 , n if ( k . lt . 2 ** ( n - i )) exit k = k - 2 ** ( n - i ) end do k = k + 2 ** ( n - i ) end do k = 0 do ib = 1 , nnb kkk ( ib , n ) = k do i = 1 , n if ( k . lt . 2 ** ( n - i )) exit k = k - 2 ** ( n - i ) end do k = k + 2 ** ( n - i ) end do end do end subroutine fourier_coefs subroutine meyer_yamada () !! !!   We load into memory the values of the Meyer wavelet function, !!   which are used when computing the wavelet transform of an input data. !! implicit none real * 8 :: omega1 , omega2 integer j , is , kmax c1 = wave ( twopi , 2 ) c2 = wave ( pi , 2 ) do j = 1 , 12 kmax = 2 ** ( j - 1 ) do is = 1 , kmax omega1 = twopi * ( is - 1 ) / ( kmax ) omega2 = omega1 + twopi rwt1 ( is , j ) = wave ( omega1 , 2 ) rwt2 ( is , j ) = wave ( omega2 , 2 ) end do end do end subroutine meyer_yamada function wave ( w , ic ) result ( wave1 ) !! !!  Meyer wavelet function in frequency domain. !! implicit none real * 8 :: w integer :: ic integer :: i , j , k real * 8 , parameter :: p43 = 4.d0 * pi / 3.d0 , p23 = 2.d0 * pi / 3.d0 real * 8 :: g ( 2 ), p ( 2 ), fw , wf , wd , wp , wg , ww , hw , cct complex * 16 :: pp , a complex :: wave1 hw = w * 0.5d0 a = cmplx ( cos ( hw ), - sin ( hw ), kind ( 1.d0 )) ww = abs ( w ) if ( ww . gt . ( 2.d0 * p43 ) . or . ww . lt . p23 ) then wave1 = cmplx ( 0.0 , 0.0 ) return end if do i = 1 , 2 wp = hw * i fw = 1.d0 do j = 1 , 2 if ( j . eq . 1 ) wf = - wp if ( j . eq . 2 ) wf = wp do k = 1 , 2 if ( k . eq . 1 ) wd = p43 - wf if ( k . eq . 2 ) wd = wf - p23 if ( wd . le . 0 ) then g ( k ) = 0.d0 else g ( k ) = exp ( - 1.d0 / wd / wd ) end if end do wg = g ( 1 ) / ( g ( 1 ) + g ( 2 )) fw = fw * wg end do p ( i ) = fw end do cct = p ( 1 ) - p ( 2 ) pp = a * dsqrt ( cct ) if ( ic . eq . 1 ) then wave1 = pp else wave1 = cmplx ( real ( pp ), - aimag ( pp )) end if end function wave subroutine realtr ( xr , xi , n ) implicit none real xr ( * ), xi ( * ) integer :: n integer :: i , i1 , i2 , lh , lb lh = 2 ** ( n - 1 ) lb = lh - 1 lh = lh + 1 do i = 1 , lb i1 = lh + I i2 = lh - I xr ( i1 ) = xr ( i2 ) xi ( i1 ) = - xi ( i2 ) end do xi ( lh ) = 0.0 end subroutine realtr end module wavelets","title":"wavelets.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/get_stations_data.f95.html","text":"Contents Modules get_stations_data Source Code get_stations_data.f95 Source Code module get_stations_data use constants , only : nnsta , nnxy , max_seg , npuse , inptd , npth , n_data use wavelet_param , only : lnpt , nlen , jmin , jmax , jfmax use wavelets , only : meyer_yamada , wavelet_obs implicit none integer , parameter :: nnsta_tele = 80 real :: weight ( nnsta ), wave_obs ( npth , nnsta ), wmax ( nnsta ), dt_channel ( nnsta ) integer :: misfit_type ( 12 , nnsta ), t_max ( nnsta ), t_max_val ( nnsta ) real :: wavelet_weight ( 12 , nnsta ) contains subroutine get_data ( strong , cgps , body , surf , dart ) implicit none !! !!  We load into memory, wavelet transform of observed data, and !!  other properties of stations !! integer :: ll_in , ll_out logical :: strong , cgps , body , surf , dart real erm complex z0 z0 = cmplx ( 0.0 , 0.0 ) erm = 0.0 call meyer_yamada () ll_in = 0 ll_out = 0 dt_channel (:) = 0.0 if ( strong ) then call get_strong_motion_stations ( ll_in , ll_out ) ll_in = ll_out end if if ( cgps ) then call get_cgps_stations ( ll_in , ll_out ) ll_in = ll_out end if if ( body ) then call get_body_waves_stations ( ll_in , ll_out ) ll_in = ll_out end if if ( surf ) then call get_surface_waves_stations ( ll_in , ll_out ) ll_in = ll_out end if if ( dart ) then call get_dart_stations ( ll_in , ll_out ) ll_in = ll_out end if !   select case (io_data) !      case (1) !         call get_cgps_stations(ll_in, ll_out) !      case (2) !         call get_strong_motion_stations(ll_in, ll_out) !      case (3) !         call get_body_waves_stations(ll_in, ll_out) !      case (4) !         call get_strong_motion_stations(ll_in, ll_out) !         lL_in = ll_out !         call get_cgps_stations(ll_in, ll_out) !      case (5) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_stations(ll_in, ll_out) !      case (6) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_stations(ll_in, ll_out) !      case (7) !         call get_strong_motion_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !      case (8) !         call get_cgps_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !      case (9) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !      case (10) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_stations(ll_in, ll_out) !         ll_in = lL_out !         call get_cgps_stations(ll_in, ll_out) !      case (11) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_stations(ll_in, ll_out) !      case (12) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_stations(ll_in, ll_out) !      case (13) !         call get_strong_motion_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !         lL_in = ll_out !         call get_cgps_stations(ll_in, ll_out) !      case (14) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_stations(ll_in, ll_out) !      case (15) !         call get_body_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_stations(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_stations(ll_in, ll_out) !   endselect end subroutine get_data subroutine get_strong_motion_stations ( ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , & & nstb , io_chan , nm , j_con ( 11 ), i , k , ir , no , & & n_wave_weight , ir_max , n_chan , & & nos ( nnsta ), io_mod ( nnsta ), n_chan3 real cr ( inptd ), cz ( inptd ), obser ( n_data ), & & lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , depth , & & dto , amp_max , weig ( nnsta ), j_wig ( 11 ), df , dt_sample , & & obse ( n_data , nnsta ), tlen character ( len = 40 ) string character ( len = 6 ) sta_name ( nnsta ) character ( len = 3 ) component ( nnsta ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! open ( 9 , file = 'Readlp.inf' , status = 'old' ) open ( 13 , file = 'Obser.str' , status = 'unknown' ) open ( 15 , file = 'Wave.str' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , * ) read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) lnpt , dt_sample read ( 9 , * ) nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations betweeen wavelet file and stations file' stop end if ir = 0 io_chan = 0 df = 1. / (( 2 ** lnpt ) * dt ) do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), component ( ir ), weig ( ir ), nos ( ir ) if ( weig ( ir ) . gt . 0 ) n_chan3 = n_chan3 + 1 end do close ( 9 ) write ( * , * ) 'n_chan: ' , n_chan3 do ir = 1 , ir_max io_chan = io_chan + 1 ll_g = io_chan + ll_in weight ( ll_g ) = weig ( ir ) / n_chan3 dt_channel ( ll_g ) = dt_sample read ( 13 , * ) read ( 13 , * ) read ( 13 , * ) string , dto read ( 13 , * ) string , no read ( 13 , * ) string , t_max ( ll_g ) read ( 13 , * ) read ( 13 , * )( obse ( i , ll_g ), i = 1 , no ) do i = 1 , inptd cz ( i ) = 0.0 cr ( i ) = 0.0 if ( i . lt . no ) then obser ( i ) = obse ( i , ll_g ) else obser ( i ) = 0.0 end if end do call wavelet_obs ( cr , cz , obser ) amp_max = 0.0 nm = 1 do i = 1 , nlen if ( amp_max . lt . abs ( obser ( i ))) then amp_max = abs ( obser ( i )) nm = i end if end do wmax ( ll_g ) = amp_max t_max_val ( ll_g ) = nm do i = 1 , nlen wave_obs ( i , ll_g ) = obser ( i ) / ( amp_max ) end do do k = 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do read ( 15 , * ) read ( 15 , * )( j_con ( k ), k = 1 , jmax ) read ( 15 , * )( j_wig ( k ), k = 1 , jmax ) do k = jmin , jmax misfit_type ( k , ll_g ) = j_con ( k ) wavelet_weight ( k , ll_g ) = real ( j_wig ( k )) end do do k = jmax + 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do end do close ( 13 ) close ( 15 ) ll_out = ll_in + n_chan end subroutine get_strong_motion_stations subroutine get_cgps_stations ( ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , & & nstb , io_chan , nm , j_con ( 11 ), i , k , ir , no , & & n_wave_weight , ir_max , n_chan , & & nos ( nnsta ), io_mod ( nnsta ), n_chan3 real cr ( inptd ), cz ( inptd ), obser ( n_data ), & & lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , depth , & & dto , amp_max , weig ( nnsta ), j_wig ( 11 ), df , dt_sample , & & obse ( n_data , nnsta ), tlen character ( len = 40 ) string character ( len = 6 ) sta_name ( nnsta ) character ( len = 3 ) component ( nnsta ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! open ( 9 , file = 'Readlp.cgps' , status = 'old' ) open ( 13 , file = 'Obser.cgps' , status = 'unknown' ) open ( 15 , file = 'Wave.cgps' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , * ) read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) lnpt , dt_sample read ( 9 , * ) nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations betweeen wavelet file and stations file' stop end if ir = 0 io_chan = 0 df = 1. / (( 2 ** lnpt ) * dt ) do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), component ( ir ), weig ( ir ), nos ( ir ) if ( weig ( ir ) . gt . 0 ) n_chan3 = n_chan3 + 1 end do close ( 9 ) do ir = 1 , ir_max io_chan = io_chan + 1 ll_g = io_chan + ll_in weight ( ll_g ) = weig ( ir ) / n_chan3 dt_channel ( ll_g ) = dt_sample read ( 13 , * ) read ( 13 , * ) read ( 13 , * ) string , dto read ( 13 , * ) string , no read ( 13 , * ) string , t_max ( ll_g ) read ( 13 , * ) read ( 13 , * )( obse ( i , ll_g ), i = 1 , no ) do i = 1 , inptd cz ( i ) = 0.0 cr ( i ) = 0.0 if ( i . lt . no ) then obser ( i ) = obse ( i , ll_g ) else obser ( i ) = 0.0 end if end do call wavelet_obs ( cr , cz , obser ) amp_max = 0.0 nm = 1 do i = 1 , nlen if ( amp_max . lt . abs ( obser ( i ))) then amp_max = abs ( obser ( i )) nm = i end if end do wmax ( ll_g ) = amp_max t_max_val ( ll_g ) = nm do i = 1 , nlen wave_obs ( i , ll_g ) = obser ( i ) / ( amp_max ) end do do k = 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do read ( 15 , * ) read ( 15 , * )( j_con ( k ), k = 1 , jmax ) read ( 15 , * )( j_wig ( k ), k = 1 , jmax ) do k = jmin , jmax misfit_type ( k , ll_g ) = j_con ( k ) wavelet_weight ( k , ll_g ) = real ( j_wig ( k )) end do do k = jmax + 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do end do close ( 13 ) close ( 15 ) ll_out = ll_in + n_chan end subroutine get_cgps_stations subroutine get_body_waves_stations ( ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , & & nstb , nm , j_con ( 11 ), i , k , ir , no , n_wave_weight , n_chan , & & nos ( nnsta_tele ), n_chan3 , idts , & & nstaon , mmm ( nnsta_tele ), love , llove ( nnsta_tele ), & & idata ( nnsta_tele ), int1 real cr ( inptd ), cz ( inptd ), obser ( n_data ), & & lat_sta ( nnsta_tele ), lon_sta ( nnsta_tele ), & & dto , amp_max , j_wig ( 11 ), dt , & & obse ( n_data , nnsta ), & & rang ( nnsta_tele ), az ( nnsta_tele ), earth_angle ( nnsta_tele ), & & disp_or_vel ( nnsta_tele ), float1 , float2 character ( len = 40 ) string character ( len = 6 ) earth ( nnsta_tele ), sttyp ( nnsta_tele ), stname ( nnsta_tele ) character ( len = 14 ) fname ( nnsta_tele ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! open ( 9 , file = 'Readlp.das' , status = 'old' ) open ( 13 , file = 'Obser.tele' , status = 'unknown' ) open ( 14 , file = 'Weight' ) if ( jfmax . gt . npuse ) then write ( * , * ) 'You should stop and check dimension sww,sws' stop end if read ( 9 , * ) read ( 9 , * ) idts , lnpt , dt read ( 9 , * ) read ( 9 , * ) nstaon nstb = 0 nlen = 2 ** lnpt open ( 15 , file = 'Wave.tele' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , * ) n_wave_weight do ir = 1 , nstaon ll_g = ll_in + ir read ( 14 , * ) weight ( ll_g ) if ( weight ( ll_g ) . gt . 0 ) n_chan3 = n_chan3 + 1 end do rewind 14 write ( * , * ) 'n_chan: ' , n_chan3 n_chan = nstaon do ir = 1 , nstaon read ( 9 , * ) nos ( ir ), earth ( ir ), sttyp ( ir ), stname ( ir ), fname ( ir ), & & rang ( ir ), az ( ir ), lat_sta ( ir ), lon_sta ( ir ), earth_angle ( ir ), float1 , & & mmm ( ir ), float2 , disp_or_vel ( ir ), llove ( ir ), int1 , idata ( ir ) ll_g = ir + ll_in if ( idata ( ir ) . gt . 0 . or . mmm ( ir ) . eq . 3 ) cycle nstb = nstb + 1 dt_channel ( ll_g ) = dt read ( 14 , * ) weight ( ll_g ) weight ( ll_g ) = weight ( ll_g ) / n_chan3 love = llove ( ir ) read ( 13 , * ) read ( 13 , * ) read ( 13 , * ) string , dto read ( 13 , * ) string , no read ( 13 , * ) string , t_max ( ll_g ) read ( 13 , * ) read ( 13 , * )( obse ( i , ll_g ), i = 1 , no ) do i = 1 , inptd cz ( i ) = 0.0 cr ( i ) = 0.0 if ( i . lt . no ) then obser ( i ) = obse ( i , ll_g ) else obser ( i ) = 0.0 end if end do call wavelet_obs ( cr , cz , obser ) amp_max = 0.0 nm = 1 do i = 1 , nlen if ( amp_max . lt . abs ( obser ( i ))) then amp_max = abs ( obser ( i )) nm = i end if end do wmax ( ll_g ) = amp_max t_max_val ( ll_g ) = nm do i = 1 , nlen wave_obs ( i , ll_g ) = obser ( i ) / ( amp_max ) end do do k = 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do read ( 15 , * ) read ( 15 , * )( j_con ( k ), k = 1 , jmax ) read ( 15 , * )( j_wig ( k ), k = 1 , jmax ) do k = jmin , jmax misfit_type ( k , ll_g ) = j_con ( k ) wavelet_weight ( k , ll_g ) = real ( j_wig ( k )) end do do k = jmax + 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do end do close ( 9 ) close ( 13 ) close ( 14 ) close ( 15 ) ll_out = ll_in + n_chan end subroutine get_body_waves_stations subroutine get_surface_waves_stations ( ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , & & nstb , io_chan , nm , j_con ( 11 ), i , k , ir , no , & & n_wave_weight , ir_max , n_chan , & & nos ( nnsta ), io_mod ( nnsta ), n_chan3 , io_up ( nnsta ), & & io_ns ( nnsta ), idts , io_ew ( nnsta ), io_str ( nnsta ) real cr ( inptd ), cz ( inptd ), obser ( n_data ), & & lat_s ( nnsta ), lon_s ( nnsta ), dt , & & ang_ns ( nnsta ), ang_ew ( nnsta ), dto , amp_max , & & weig ( nnsta , 3 ), j_wig ( 11 ), df , dt_sample , & & obse ( n_data , nnsta ), dip , rake , theta , tlen character ( len = 40 ) string character ( len = 6 ) sta_name ( nnsta ) character ( len = 250 ) modes n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! open ( 9 , file = 'Readlp.inf_low' , status = 'old' ) open ( 13 , file = 'Obser.str_low' , status = 'unknown' ) open ( 15 , file = 'Wave.str_low' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , '(a)' ) modes read ( 15 , * ) n_wave_weight idts = 3 read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) dip , rake , theta , lnpt , dt_sample read ( 9 , * ) if ( lnpt . ne . 10 ) then write ( * , * ) \"please check input LNPT\" end if nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations between wavelet file and stations file' stop end if ! !       Here we read the green functions of long period surface waves ! do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), & & io_up ( ir ), io_ns ( ir ), io_ew ( ir ), ang_ns ( ir ), ang_ew ( ir ), & & io_str ( ir ),( weig ( ir , k ), k = 1 , 3 ), nos ( ir ) if (( weig ( ir , 1 ) . gt . 0 ) . and . ( io_up ( ir ) . eq . 1 )) n_chan3 = n_chan3 + 1 if (( weig ( ir , 2 ) . gt . 0 ) . and . ( io_ns ( ir ) . eq . 1 )) n_chan3 = n_chan3 + 1 end do close ( 9 ) io_chan = 0 do ir = 1 , n_chan if ( io_up ( ir ) . eq . 1 ) then io_chan = io_chan + 1 ll_g = io_chan + ll_in weight ( ll_g ) = weig ( ir , 1 ) / n_chan3 end if if ( io_ns ( ir ) . eq . 1 ) then io_chan = io_chan + 1 ll_g = io_chan + ll_in weight ( ll_g ) = weig ( ir , 2 ) / n_chan3 end if end do io_chan = 0 do ir = 1 , n_chan io_chan = io_chan + 1 ll_g = io_chan + ll_in dt_channel ( ll_g ) = dt_sample read ( 13 , * ) read ( 13 , * ) read ( 13 , * ) string , dto read ( 13 , * ) string , no read ( 13 , * ) string , t_max ( ll_g ) read ( 13 , * ) read ( 13 , * )( obse ( i , ll_g ), i = 1 , no ) do i = 1 , inptd cz ( i ) = 0.0 cr ( i ) = 0.0 if ( i . lt . no ) then obser ( i ) = obse ( i , ll_g ) else obser ( i ) = 0.0 end if end do call wavelet_obs ( cr , cz , obser ) amp_max = 0.0 nm = 1 do i = 1 , nlen if ( amp_max . lt . abs ( obser ( i ))) then amp_max = abs ( obser ( i )) nm = i end if end do wmax ( ll_g ) = amp_max t_max_val ( ll_g ) = nm do i = 1 , nlen wave_obs ( i , ll_g ) = obser ( i ) / ( amp_max ) end do do k = 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do read ( 15 , * ) read ( 15 , * )( j_con ( k ), k = 1 , jmax ) read ( 15 , * )( j_wig ( k ), k = 1 , jmax ) do k = jmin , jmax misfit_type ( k , ll_g ) = j_con ( k ) wavelet_weight ( k , ll_g ) = real ( j_wig ( k )) end do do k = jmax + 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do end do close ( 13 ) close ( 15 ) ll_out = ll_out + n_chan end subroutine get_surface_waves_stations subroutine get_dart_stations ( ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , & & nstb , io_chan , nm , j_con ( 11 ), i , k , ir , no , & & n_wave_weight , ir_max , n_chan , & & nos ( nnsta ), io_mod ( nnsta ), n_chan3 real cr ( inptd ), cz ( inptd ), obser ( n_data ), & & lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , depth , & & dto , amp_max , weig ( nnsta ), j_wig ( 11 ), df , dt_sample , & & obse ( n_data , nnsta ), tlen character ( len = 40 ) string character ( len = 6 ) sta_name ( nnsta ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! open ( 9 , file = 'Readlp.dart' , status = 'old' ) open ( 13 , file = 'Obser.dart' , status = 'unknown' ) open ( 15 , file = 'Wave.dart' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , * ) read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) lnpt , dt_sample read ( 9 , * ) nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations betweeen wavelet file and stations file' stop end if ir = 0 io_chan = 0 df = 1. / (( 2 ** lnpt ) * dt ) do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), weig ( ir ), nos ( ir ) if ( weig ( ir ) . gt . 0 ) n_chan3 = n_chan3 + 1 end do close ( 9 ) do ir = 1 , ir_max io_chan = io_chan + 1 ll_g = io_chan + ll_in weight ( ll_g ) = weig ( ir ) / n_chan3 dt_channel ( ll_g ) = dt_sample read ( 13 , * ) read ( 13 , * ) read ( 13 , * ) string , dto read ( 13 , * ) string , no read ( 13 , * ) string , t_max ( ll_g ) read ( 13 , * ) read ( 13 , * )( obse ( i , ll_g ), i = 1 , no ) do i = 1 , inptd cz ( i ) = 0.0 cr ( i ) = 0.0 if ( i . lt . no ) then obser ( i ) = obse ( i , ll_g ) else obser ( i ) = 0.0 end if end do call wavelet_obs ( cr , cz , obser ) amp_max = 0.0 nm = 1 do i = 1 , nlen if ( amp_max . lt . abs ( obser ( i ))) then amp_max = abs ( obser ( i )) nm = i end if end do wmax ( ll_g ) = amp_max t_max_val ( ll_g ) = nm do i = 1 , nlen wave_obs ( i , ll_g ) = obser ( i ) / ( amp_max ) end do do k = 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do read ( 15 , * ) read ( 15 , * )( j_con ( k ), k = 1 , jmax ) read ( 15 , * )( j_wig ( k ), k = 1 , jmax ) do k = jmin , jmax misfit_type ( k , ll_g ) = j_con ( k ) wavelet_weight ( k , ll_g ) = real ( j_wig ( k )) end do do k = jmax + 1 , 11 misfit_type ( k , ll_g ) = 0 wavelet_weight ( k , ll_g ) = 0 end do end do close ( 13 ) close ( 15 ) ll_out = ll_in + n_chan end subroutine get_dart_stations end module get_stations_data","title":"get_stations_data.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/run_modelling.f95.html","text":"Contents Programs run_modelling Source Code run_modelling.f95 Source Code program run_modelling use constants , only : max_seg , nt1 , nnxy use model_parameters , only : get_faults_data , get_model_space , get_special_boundaries , subfault_positions , & & write_model use modelling_inputs , only : get_annealing_param , n_iter , io_re , cooling_rate , t_stop , t_mid , t0 , io_data , idum use get_stations_data , only : get_data use retrieve_gf , only : get_gf , deallocate_gf use save_forward , only : write_forward use rise_time , only : get_source_fun , deallocate_source use static_data , only : initial_gps use random_gen , only : start_seed use annealing , only : initial_model , initial_regularization , annealing_iter , annealing_iter2 , & & annealing_iter3 , annealing_iter4 , n_threads implicit none integer :: i real :: slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ) real :: tl ( nnxy , max_seg ), tr ( nnxy , max_seg ) real :: er , t logical :: static , strong , cgps , dart , body , surf , auto character ( len = 10 ) :: input static = . False . strong = . False . cgps = . False . body = . False . surf = . False . dart = . False . auto = . False . do i = 1 , iargc () call getarg ( i , input ) input = trim ( input ) if ( input . eq . 'gps' ) static = . True . if ( input . eq . 'strong' ) strong = . True . if ( input . eq . 'cgps' ) cgps = . True . if ( input . eq . 'body' ) body = . True . if ( input . eq . 'surf' ) surf = . True . if ( input . eq . 'dart' ) dart = . True . if ( input . eq . 'auto' ) auto = . True . end do call n_threads ( auto ) call get_annealing_param () call start_seed ( idum ) call get_faults_data () call get_model_space () call get_special_boundaries () call subfault_positions () write ( * , * ) io_data call get_gf ( strong , cgps , body , surf , dart ) call get_data ( strong , cgps , body , surf , dart ) call get_source_fun () call initial_model ( slip , rake , rupt_time , tl , tr ) if ( static ) call initial_gps ( slip , rake ) call initial_regularization ( slip , rake , rupt_time , tl , tr , static ) t = t_mid if ( io_re . eq . 0 ) t = t0 if ( static ) then do i = 1 , n_iter call annealing_iter4 ( slip , rake , rupt_time , tl , tr , er , t ) write ( * , * ) 'iter: ' , i if ( t . lt . t_stop ) then t = t * 0.995 else t = t * cooling_rate end if end do else do i = 1 , n_iter call annealing_iter3 ( slip , rake , rupt_time , tl , tr , er , t ) write ( * , * ) 'iter: ' , i if ( t . lt . t_stop ) then t = t * 0.995 else t = t * cooling_rate end if end do end if call write_forward ( slip , rake , rupt_time , tl , tr , strong , cgps , body , surf , dart ) call initial_gps ( slip , rake ) call write_model ( slip , rake , rupt_time , tl , tr ) call deallocate_source () call deallocate_gf () end program run_modelling","title":"run_modelling.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/random_gen.f95.html","text":"Contents Modules random_gen Source Code random_gen.f95 Source Code module random_gen implicit none integer , parameter , private :: ia = 16807 , im = 2147483647 , iq = 127773 , ir = 2836 , ntab = 32 , ndiv = 1 + int (( im - 1 ) / ntab ) real , parameter , private :: am = 1. / im , eps = 1.2e-7 , rnmx = 1.0 - eps integer :: iv ( ntab ), iy !   data iv/ntab*0/, iy/0/ integer , parameter , private :: mbig = 1000000000 , midum = 161803398 , mz = 0 real , parameter , private :: fac = 1.e-9 integer :: iff , inext , inextp , ma ( 55 ) !   data iff/0/ integer :: seed contains subroutine start_seed ( idum ) implicit none integer , intent ( in ) :: idum seed = idum iff = 0 iv (:) = 0 iy = 0 end subroutine start_seed function ran1 () result ( random ) implicit none integer :: j , k real :: random if ( seed . le . 0 . or . iy . eq . 0 ) then seed = max ( - seed , 1 ) do j = ntab + 8 , 1 , - 1 k = seed / iq seed = ia * ( seed - k * iq ) - ir * k if ( seed . lt . 0 ) seed = seed + im if ( j . le . ntab ) iv ( j ) = seed end do iy = iv ( 1 ) end if k = seed / iq seed = ia * ( seed - k * iq ) - ir * k if ( seed . lt . 0 ) seed = seed + im j = 1 + iy / ndiv iy = iv ( j ) iv ( j ) = seed random = min ( am * iy , rnmx ) end function ran1 function ran3 () result ( random ) ! !*****  routine to generate a uniformly distributed random ***** !*****  number on the interval [0, 1].                      ***** ! implicit none integer :: i , ii , k , mj , mk real :: random if ( seed . lt . 0 . or . iff . eq . 0 ) then iff = 1 mj = midum - iabs ( seed ) mj = mod ( mj , mbig ) ma ( 55 ) = mj mk = 1 do i = 1 , 54 ii = mod ( 21 * i , 55 ) ma ( ii ) = mk mk = mj - mk if ( mk . lt . mz ) mk = mk + mbig mj = ma ( ii ) end do do k = 1 , 4 do i = 1 , 55 ma ( i ) = ma ( i ) - ma ( 1 + mod ( i + 30 , 55 )) if ( ma ( i ) . lt . mz ) ma ( i ) = ma ( i ) + mbig end do end do inext = 0 inextp = 31 seed = 1 end if inext = inext + 1 if ( inext . eq . 56 ) inext = 1 inextp = inextp + 1 if ( inextp . eq . 56 ) inextp = 1 mj = ma ( inext ) - ma ( inextp ) if ( mj . lt . mz ) mj = mj + mbig ma ( inext ) = mj random = mj * fac end function ran3 subroutine cauchy ( t , x ) implicit none real , intent ( in ) :: t real , intent ( out ) :: x real :: u , sgn , uu u = ran3 () sgn = 1. if (( u - 0.5 ) . lt . 0. ) sgn = - 1. uu = abs ( 2. * u - 1. ) x = sgn * t * (( 1. + 1. / t ) ** uu - 1. ) end subroutine cauchy end module random_gen","title":"random_gen.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/static_data.f95.html","text":"Contents Modules static_data Source Code static_data.f95 Source Code !     This program load the static subfault GFs and generate the matrix !     for baseline correction.         Ji, Chen, 2003 !     Reviewed. The previous version have an error in loading GFs. ! !                                   Ji, Chen, 2004 !  Fixed ! ! ! module static_data use constants , only : nnxy , max_seg , dpi use model_parameters , only : nxs_sub , nys_sub , delay_seg , dip_seg , stk_seg , nx_p , ny_p , n_seg implicit none integer , parameter , private :: n_stations = 500 integer :: n_chan real * 8 :: synm_whole ( n_stations , 3 ), weight_sum real :: lat ( n_stations ), lon ( n_stations ) real :: green ( n_stations , 6 , nnxy , max_seg ), syn_disp ( n_stations , 3 ) real :: obse ( n_stations , 3 ), weight ( n_stations , 3 ) character ( len = 6 ) :: sta_name ( n_stations ) contains subroutine initial_gps ( dd , aa ) !! !!   Load static GF and compute synthetic displacements from a fault model. !! integer k , j , i_s , ir , no , nxy , i , i_seg integer iys , ixs , n_tt real dd ( nnxy , max_seg ), aa ( nnxy , max_seg ) real :: cosal , sinal , angle real * 8 :: disp logical is_file ! inquire ( file = 'Readlp.static' , exist = is_file ) if ( is_file ) then weight_sum = 0.d0 open ( 9 , file = 'Readlp.static' ) read ( 9 , * ) n_chan read ( 9 , * ) do i = 1 , n_chan read ( 9 , * ) no , sta_name ( i ), lat ( i ), lon ( i ), ( obse ( i , k ), k = 1 , 3 ), ( weight ( i , k ), k = 1 , 3 ) do k = 1 , 3 weight_sum = weight_sum + weight ( i , k ) end do end do close ( 9 ) open ( 33 , file = 'Green_static_subfault' ) read ( 33 , * ) n_tt do ir = 1 , n_chan read ( 33 , * ) do i_seg = 1 , n_seg read ( 33 , * ) nxy = 0 do iys = 1 , nys_sub ( i_seg ) do ixs = 1 , nxs_sub ( i_seg ) nxy = nxy + 1 read ( 33 , * )( green ( ir , k , nxy , i_seg ), k = 1 , 6 ) end do end do end do end do close ( 33 ) do k = 1 , 3 j = 2 * k - 1 do ir = 1 , n_chan disp = 0.d0 do i_s = 1 , n_seg nxy = 0 do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) nxy = nxy + 1 angle = aa ( nxy , i_s ) * dpi sinal = sin ( angle ) cosal = cos ( angle ) disp = disp + dd ( nxy , i_s ) & & * ( sinal * green ( ir , j , nxy , i_s ) + cosal * green ( ir , j + 1 , nxy , i_s )) end do end do end do syn_disp ( ir , k ) = disp end do end do open ( 10 , file = 'synm.static' ) write ( 10 , * ) n_chan do ir = 1 , n_chan write ( 10 , * ) ir , sta_name ( ir ), lat ( ir ), lon ( ir ),( syn_disp ( ir , k ), k = 1 , 3 ) end do close ( 10 ) end if end subroutine initial_gps subroutine static_synthetic ( dd , aa , nxys , err ) !! !!   Load static synthetic displacements from a fault model. !! real dd ( nnxy , max_seg ), aa ( nnxy , max_seg ) !, err integer k , j , i_s , ir , nxys ( max_seg ), nxy real err , dif , angle , sinal , cosal real * 8 :: disp , err2 err2 = 0.d0 synm_whole (:, :) = 0.d0 do k = 1 , 3 j = 2 * k - 1 do ir = 1 , n_chan disp = 0.d0 do i_s = 1 , n_seg do nxy = 1 , nxys ( i_s ) angle = aa ( nxy , i_s ) * dpi sinal = sin ( angle ) cosal = cos ( angle ) disp = disp + dd ( nxy , i_s ) & & * ( sinal * green ( ir , j , nxy , i_s ) + cosal * green ( ir , j + 1 , nxy , i_s )) end do end do synm_whole ( ir , k ) = disp dif = synm_whole ( ir , k ) - obse ( ir , k ) err2 = err2 + weight ( ir , k ) * dif * dif / 10 0.0 end do end do err2 = sqrt (( err2 / weight_sum )) err = real ( err2 ) end subroutine static_synthetic subroutine static_remove_subfault ( dd , aa , n_s , n_sub ) !! !!   Remove static response of current subfault, for all static stations. !! real , intent ( in ) :: dd ( nnxy , max_seg ), aa ( nnxy , max_seg ) integer , intent ( in ) :: n_s , n_sub integer k , j , ir real disp , angle , sinal , cosal ! angle = aa ( n_sub , n_s ) * dpi sinal = sin ( angle ) cosal = cos ( angle ) do k = 1 , 3 j = 2 * k - 1 do ir = 1 , n_chan disp = dd ( n_sub , n_s ) & & * ( sinal * green ( ir , j , n_sub , n_s ) + cosal * green ( ir , j + 1 , n_sub , n_s )) synm_whole ( ir , k ) = synm_whole ( ir , k ) - disp end do end do end subroutine static_remove_subfault pure subroutine static_modify_subfault ( slip , rake , n_s , n_sub , err ) !! !!   We add the static response of the current subfault, for all static stations. !!   We compute misfit of static data !! real , intent ( in ) :: slip , rake real , intent ( out ) :: err integer , intent ( in ) :: n_s , n_sub integer k , j , ir real disp , angle , dif , sinal , cosal real * 8 :: err2 ! angle = rake * dpi sinal = sin ( angle ) cosal = cos ( angle ) err2 = 0.d0 do k = 1 , 3 j = 2 * k - 1 do ir = 1 , n_chan disp = slip & & * ( sinal * green ( ir , j , n_sub , n_s ) + cosal * green ( ir , j + 1 , n_sub , n_s )) dif = ( synm_whole ( ir , k ) + disp ) - obse ( ir , k ) err2 = err2 + weight ( ir , k ) * dif * dif / 10 0.0 end do end do err2 = sqrt ( err2 / weight_sum ) err = real ( err2 ) end subroutine static_modify_subfault subroutine static_add_subfault ( dd , aa , n_s , n_sub , err ) !! !!   Add static response of current subfault, for all stations. !!   Compute the misfit error of static data !! real , intent ( in ) :: dd ( nnxy , max_seg ), aa ( nnxy , max_seg ) real , intent ( out ) :: err integer , intent ( in ) :: n_s , n_sub integer k , j , ir real disp , angle , dif , sinal , cosal real * 8 :: err2 ! angle = aa ( n_sub , n_s ) * dpi sinal = sin ( angle ) cosal = cos ( angle ) err2 = 0.d0 do k = 1 , 3 j = 2 * k - 1 do ir = 1 , n_chan disp = dd ( n_sub , n_s ) & & * ( sinal * green ( ir , j , n_sub , n_s ) + cosal * green ( ir , j + 1 , n_sub , n_s )) synm_whole ( ir , k ) = synm_whole ( ir , k ) + disp dif = synm_whole ( ir , k ) - obse ( ir , k ) err2 = err2 + weight ( ir , k ) * dif * dif / 10 0.0 end do end do err2 = sqrt ( err2 / weight_sum ) err = real ( err2 ) end subroutine static_add_subfault end module static_data","title":"static_data.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/wavelet_param.f95.html","text":"Contents Modules wavelet_param Source Code wavelet_param.f95 Source Code module wavelet_param implicit none integer :: lnpt , nlen , jmin , jmax , jfmax end module wavelet_param","title":"wavelet_param.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/model_parameters.f95.html","text":"Contents Modules model_parameters Source Code model_parameters.f95 Source Code module model_parameters use constants , only : max_seg , nnpx , nnpy , nnxs , nnys , nnxy , nt1 use modelling_inputs , only : t_latest implicit none real :: slip0 ( nnxy , max_seg ), rake0 ( nnxy , max_seg ), rupt_time0 ( nnxy , max_seg ) real :: tl0 ( nnxy , max_seg ), tr0 ( nnxy , max_seg ) integer :: n_seg , nxs_sub ( max_seg ), nys_sub ( max_seg ), nx_p , ny_p , nxs0 , nys0 real :: dip_seg ( max_seg ), stk_seg ( max_seg ), delay_seg ( max_seg ) real :: point_sources ( 7 , nnpx , nnpy , nnxs , nnys , max_seg ) real :: cniu ( nnxy , max_seg ) real :: c_depth , dxs , dys , v_ref , v_min , v_max , tbl , tbr real :: ta0 , dta real :: time_min ( nnxy , max_seg ), time_max ( nnxy , max_seg ), rake_min integer :: msou , jfmax real :: beg ( nt1 ), dp ( nt1 ) integer :: np ( nt1 ) ! ! for regularization ! integer :: nleft ( 3 , nnys , nnxs , max_seg ), nright ( 3 , nnys , nnxs , max_seg ), & & nup ( 3 , nnys , nnxs , max_seg ), ndown ( 3 , nnys , nnxs , max_seg ) contains subroutine get_faults_data () !! !!  Read and stores in memory properties of the fault plane. !! implicit none integer n_s , i_s , io_x , io_y , ixs , iys , io_v_d , nxy , k , nxys ( max_seg ), & & i_seg , ix , iy , ll , io_seg , kxy , kpxy , nx_c , ny_c real dist , t_ref , t_max , t_min , delta , dip_s , stk_s ! !     Input Fault position to memory ! open ( 12 , file = 'Fault.time' ) read ( 12 , * ) nxs0 , nys0 , c_depth read ( 12 , * ) n_seg , dxs , dys , nx_p , ny_p , v_min , v_max , tbl , tbr read ( 12 , * ) ta0 , dta , msou , v_ref , io_v_d do i_seg = 1 , n_seg write ( * , * ) i_seg , stk_seg ( 1 ), stk_seg ( 2 ) read ( 12 , * ) io_seg , dip_seg ( i_seg ), stk_seg ( i_seg ) write ( * , * ) i_seg , io_seg , stk_seg ( 1 ), stk_seg ( 2 ) read ( 12 , * ) nxs_sub ( i_seg ), nys_sub ( i_seg ), delay_seg ( i_seg ) nxy = nxs_sub ( i_seg ) * nys_sub ( i_seg ) do ll = 1 , nxy read ( 12 , * ) slip0 ( ll , i_seg ), rake0 ( ll , i_seg ), rupt_time0 ( ll , i_seg ), tl0 ( ll , i_seg ), tr0 ( ll , i_seg ) !  magic slip0 ( ll , i_seg ) = int ( slip0 ( ll , i_seg )) rake0 ( ll , i_seg ) = int ( rake0 ( ll , i_seg )) ! end do end do close ( 12 ) ! !     Input Fault model to memory ! open ( 12 , file = 'Fault.pos' ) do i_seg = 1 , n_seg read ( 12 , * ) io_seg , dip_s , stk_s if (( abs ( dip_s - dip_seg ( i_seg )) . gt . 1.e-2 ). or . & & ( abs ( stk_s - stk_seg ( i_seg )) . gt . 1.e-2 )) then write ( * , * ) 'the value in Fault.pos is not matched with that in Fault.das' write ( * , * ) i_seg write ( * , * ) dip_s , dip_seg ( i_seg ) write ( * , * ) stk_s , stk_seg ( i_seg ) end if kxy = 0 do IYS = 1 , NYS_sub ( i_seg ) do IXS = 1 , NXS_sub ( i_seg ) kxy = kxy + 1 kpxy = 0 do IY = 1 , ny_p do IX = 1 , nx_p kpxy = kpxy + 1 read ( 12 , * )( point_sources ( k , ix , iy , ixs , iys , i_seg ), k = 1 , 7 ) end do end do end do end do end do close ( 12 ) ! !  minimum and maximum subfault rupture arrival time ! nx_c = max ( int ( nx_p / 2 + 0.51 ), 1 ) ny_c = max ( int ( ny_p / 2 + 0.51 ), 1 ) kpxy = ( ny_c - 1 ) * nx_p + nx_c do i_seg = 1 , n_seg do iys = 1 , nys_sub ( i_seg ) do ixs = 1 , nxs_sub ( i_seg ) kxy = ( iys - 1 ) * nxs_sub ( i_seg ) + ixs dist = point_sources ( 4 , nx_c , ny_c , ixs , iys , i_seg ) t_ref = dist / v_ref t_max = dist / v_min if ( t_max . gt . t_latest ) t_max = t_latest t_min = dist / v_max delta = t_min - t_ref if ( tbl . lt . delta ) then time_min ( kxy , i_seg ) = delta else time_min ( kxy , i_seg ) = tbl end if delta = t_max - t_ref if ( tbr . gt . delta ) then time_max ( kxy , i_seg ) = delta else time_max ( kxy , i_seg ) = tbr end if end do end do end do ! !  Input shear modulous Model ! open ( 12 , file = 'Niu_model' ) read ( 12 , * ) n_s if ( n_s . ne . n_seg ) then write ( * , * ) 'Amount of fault segments is different between mu file and Fault file' stop end if do i_s = 1 , n_s read ( 12 , * ) io_seg , io_x , io_y nxys ( i_s ) = io_x * io_y read ( 12 , * )( cniu ( k , i_s ), k = 1 , nxys ( i_s )) end do close ( 12 ) end subroutine get_faults_data subroutine write_model ( dd , aa , tt , tl , tr ) !! !!  Save output model to a text file. !! real :: dd ( nnxy , max_seg ), aa ( nnxy , max_seg ), tt ( nnxy , max_seg ) real :: tl ( nnxy , max_seg ), tr ( nnxy , max_seg ) real :: latitude_ep , longitude_ep , t_ref , moment_sol integer :: i_seg , iys , ixs , iy , ix , i_g , kp latitude_ep = 0.0 longitude_ep = 0.0 do i_seg = 1 , n_seg do IYS = 1 , NYS_sub ( i_seg ) do IXS = 1 , NXS_sub ( i_seg ) do IY = 1 , ny_p do IX = 1 , nx_p ! ! we have found the epicenter ! if ( abs ( point_sources ( 4 , ix , iy , ixs , iys , i_seg )) . le . 1e-3 ) then latitude_ep = point_sources ( 1 , ix , iy , ixs , iys , i_seg ) longitude_ep = point_sources ( 2 , ix , iy , ixs , iys , i_seg ) end if end do end do end do end do end do open ( 13 , file = 'Solucion.txt' ) write ( 13 , * ) '#Total number of fault_segments=' , n_seg do i_g = 1 , n_seg write ( 13 , 131 ) '#Fault_segment =' , i_g , ' nx(Along-strike)=' , & & nxs_sub ( i_g ), ' Dx = ' , dxs , 'km ny(downdip)= ' , nys_sub ( i_g ), & & ' Dy = ' , dys , 'km' 131 format ( a , i4 , a , i3 , a , f5 . 2 , a , i3 , a , f5 . 2 , a ) write ( 13 , 132 ) '#Boundary of Fault_segment ' , i_g , & & '. EQ in cell (' , nxs0 , ',' , nys0 , '). Lon:' , longitude_ep , & & '   Lat:' , latitude_ep 132 format ( a , i4 , a , i2 , a , i2 , a , f10 . 4 , a , f10 . 4 ) write ( 13 , * ) '#Lon.  Lat.  Depth' write ( 13 , * ) point_sources ( 2 , 1 , 1 , 1 , 1 , i_g ), & ! ix, iy, ixs, iys, i_g), & point_sources ( 1 , 1 , 1 , 1 , 1 , i_g ), point_sources ( 3 , 1 , 1 , 1 , 1 , i_g ) write ( 13 , * ) point_sources ( 2 , 1 , ny_p , 1 , nys_sub ( i_g ), i_g ), & & point_sources ( 1 , 1 , ny_p , 1 , nys_sub ( i_g ), i_g ), & & point_sources ( 3 , 1 , ny_p , 1 , nys_sub ( i_g ), i_g ) write ( 13 , * ) & & point_sources ( 2 , nx_p , ny_p , nxs_sub ( i_g ), nys_sub ( i_g ), i_g ), & & point_sources ( 1 , nx_p , ny_p , nxs_sub ( i_g ), nys_sub ( i_g ), i_g ), & & point_sources ( 3 , nx_p , ny_p , nxs_sub ( i_g ), nys_sub ( i_g ), i_g ) write ( 13 , * ) point_sources ( 2 , nx_p , 1 , nxs_sub ( i_g ), 1 , i_g ), & & point_sources ( 1 , nx_p , 1 , nxs_sub ( i_g ), 1 , i_g ), & & point_sources ( 3 , nx_p , 1 , nxs_sub ( i_g ), 1 , i_g ) write ( 13 , * ) point_sources ( 2 , 1 , 1 , 1 , 1 , i_g ), & & point_sources ( 1 , 1 , 1 , 1 , 1 , i_g ), point_sources ( 3 , 1 , 1 , 1 , 1 , i_g ) write ( 13 , * ) '#Lat. Lon. depth slip rake strike dip t_rup t_ris t_fal mo' kp = 0 ix = int ( nx_p / 2 ) + 1 iy = int ( ny_p / 2 ) + 1 do iys = 1 , nys_sub ( i_g ) do ixs = 1 , nxs_sub ( i_g ) kp = kp + 1 t_ref = point_sources ( 5 , ix , iy , ixs , iys , i_g ) moment_sol = dd ( kp , i_g ) * cniu ( kp , i_g ) * dxs * dys * ( 1 0.0 ** 1 0.0 ) write ( 13 , 133 ) point_sources ( 1 , ix , iy , ixs , iys , i_g ), & & point_sources ( 2 , ix , iy , ixs , iys , i_g ), point_sources ( 3 , ix , iy , ixs , iys , i_g ), & & dd ( kp , i_g ), aa ( kp , i_g ), stk_seg ( i_g ), dip_seg ( i_g ), & & tt ( kp , i_g ) + t_ref , tl ( kp , i_g ), tr ( kp , i_g ), moment_sol 133 format ( f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , f14 . 6 , e14 . 6 ) end do end do end do close ( 13 ) end subroutine write_model subroutine get_model_space () !! !!  Define space of feasible kinematic models. !! implicit none integer :: nx0 , ny0 parameter ( nx0 = nnxs * 2 , ny0 = nnys * 2 ) integer :: io_surf , nblock , npa , k , i_seg , io_right , io_left , io_up , io_down real :: delt_x , delt_y , zmed_max , zmed_min , zleft_max , zleft_min real :: zright_max , zright_min , zup_max , zup_min , zdown_max , zdown_min real :: angle_max , angle_min , vel_max , vel_min real :: ddx1 , ddx2 , ddy1 , ddy2 integer :: io_seg , nmed , nleft2 , nright2 , nup2 , ndown2 , nangle , npv , nb , nsour integer :: nx , ny , i , j , k_s , i_ss , i_x , i_y real :: surface ( 1000 , 4 ), xyb ( nx0 , ny0 , 3 ), xr ( 5 ), u0 ( nt1 , 4 ) open ( 17 , file = 'bound.in' ) read ( 17 , * ) io_surf if ( io_surf . eq . 1 ) then open ( 16 , file = 'surface.constrain' ) read ( 16 , * ) nblock , io_surf do i = 1 , nblock read ( 16 , * )( surface ( i , k ), k = 1 , 4 ) end do close ( 16 ) end if npa = 0 k = 0 do i_seg = 1 , n_seg read ( 17 , * ) io_seg read ( 17 , * ) delt_x , delt_y read ( 17 , * ) io_left , io_right , io_up , io_down read ( 17 , * ) zmed_max , zmed_min , nmed read ( 17 , * ) zleft_max , zleft_min , nleft2 read ( 17 , * ) zright_max , zright_min , nright2 read ( 17 , * ) zup_max , zup_min , nup2 read ( 17 , * ) zdown_max , zdown_min , ndown2 read ( 17 , * ) angle_max , angle_min , nangle read ( 17 , * ) vel_max , vel_min , npv read ( 17 , * ) nb , nsour nx = nxs_sub ( i_seg ) ny = nys_sub ( i_seg ) rake_min = angle_min ! !  check whether the contrains is frighting eath other ! if ( io_right . eq . 1 . or . io_left . eq . 1 ) then ddx1 = ( zmed_max - zleft_max ) / ( int (( nx + 1 ) / 2 )) ddx2 = ( zmed_max - zright_max ) / ( int (( nx + 1 ) / 2 )) if ( delt_x . lt . ddx1 . or . delt_x . lt . ddx2 ) then write ( * , * ) 'the constrain of left or right boundary is error' stop end if end if if ( io_down . eq . 1 . or . io_up . eq . 1 ) then ddy1 = ( zmed_max - zup_max ) / ( int (( ny + 1 ) / 2 )) ddy2 = ( zmed_max - zdown_max ) / ( int (( ny + 1 ) / 2 )) if ( delt_y . lt . ddy1 . or . delt_y . lt . ddy2 ) then write ( * , * ) 'the constrain of left or right boundary is error' stop end if end if !  First:  Give the range of mediate part of space do i = 2 , nxs_sub ( i_seg ) - 1 do j = 2 , nys_sub ( i_seg ) - 1 xyb ( i , j , 1 ) = zmed_min xyb ( i , j , 2 ) = zmed_max xyb ( i , j , 3 ) = nmed end do end do ! !     Second: Give the value range of left and right part ! do j = 1 , nys_sub ( i_seg ) if ( io_left . eq . 1 ) then xyb ( 1 , j , 1 ) = zleft_min xyb ( 1 , j , 2 ) = zleft_max xyb ( 1 , j , 3 ) = nleft2 else xyb ( 1 , j , 1 ) = zmed_min xyb ( 1 , j , 2 ) = zmed_max xyb ( 1 , j , 3 ) = nmed end if if ( io_right . eq . 1 ) then xyb ( nxs_sub ( i_seg ), j , 1 ) = zright_min xyb ( nxs_sub ( i_seg ), j , 2 ) = zright_max xyb ( nxs_sub ( i_seg ), j , 3 ) = nright2 else xyb ( nxs_sub ( i_seg ), j , 1 ) = zmed_min xyb ( nxs_sub ( i_seg ), j , 2 ) = zmed_max xyb ( nxs_sub ( i_seg ), j , 3 ) = nmed end if end do ! !  finally: Give the value range of up and down part ! do i = 2 , nxs_sub ( i_seg ) - 1 if ( io_up . eq . 1 ) then xyb ( i , 1 , 1 ) = zup_min xyb ( i , 1 , 2 ) = zup_max xyb ( i , 1 , 3 ) = nup2 else xyb ( i , 1 , 1 ) = zmed_min xyb ( i , 1 , 2 ) = zmed_max xyb ( i , 1 , 3 ) = nmed end if if ( io_down . eq . 1 ) then xyb ( i , nys_sub ( i_seg ), 1 ) = zdown_min xyb ( i , nys_sub ( i_seg ), 2 ) = zdown_max xyb ( i , nys_sub ( i_seg ), 3 ) = ndown2 else xyb ( i , nys_sub ( i_seg ), 1 ) = zmed_min xyb ( i , nys_sub ( i_seg ), 2 ) = zmed_max xyb ( i , nys_sub ( i_seg ), 3 ) = nmed end if end do ! !  Recheck the range of mediate part ! do i = 2 , nxs_sub ( i_seg ) - 1 do j = 2 , nys_sub ( i_seg ) - 1 xr ( 1 ) = ( i - 1 ) * delt_x + zleft_max xr ( 2 ) = ( nxs_sub ( i_seg ) - i ) * delt_x + zright_max xr ( 3 ) = ( j - 1 ) * delt_y + zup_max xr ( 4 ) = ( nys_sub ( i_seg ) - j ) * delt_y + zdown_max xr ( 5 ) = xyb ( i , j , 2 ) call bbsort ( xr , 1 , 5 ) xyb ( i , j , 2 ) = xr ( 1 ) end do end do ! !  check the surface constrain ! if ( io_surf . eq . 1 ) then do k_s = 1 , nblock i_ss = int ( surface ( k_s , 1 ) + 0.1 ) if ( i_ss . eq . i_seg ) then i_y = 1 i_x = int ( surface ( k_s , 2 ) + 0.1 ) xyb ( i_x , i_y , 1 ) = surface ( k_s , 3 ) xyb ( i_x , i_y , 2 ) = surface ( k_s , 4 ) end if end do end if ! !  Change xy_range to xyb ! npa = npa + 4 * nxs_sub ( i_seg ) * nys_sub ( i_seg ) do j = 1 , nys_sub ( i_seg ) do i = 1 , nxs_sub ( i_seg ) k = k + 1 u0 ( k , 1 ) = xyb ( i , j , 1 ) u0 ( k , 2 ) = xyb ( i , j , 2 ) u0 ( k , 3 ) = xyb ( i , j , 3 ) k = k + 1 u0 ( k , 1 ) = angle_min u0 ( k , 2 ) = angle_max u0 ( k , 3 ) = nangle k = k + 1 u0 ( k , 1 ) = vel_min u0 ( k , 2 ) = vel_max u0 ( k , 3 ) = npv k = k + 1 u0 ( k , 1 ) = 1 u0 ( k , 2 ) = MSOU u0 ( k , 3 ) = MSOU end do end do end do close ( 17 ) do k = 1 , npa beg ( k ) = u0 ( k , 1 ) np ( k ) = int ( u0 ( k , 3 ) + 0.1 ) if ( np ( k ) . gt . 1 ) then dp ( k ) = ( u0 ( k , 2 ) - u0 ( k , 1 )) / ( np ( k ) - 1 ) else dp ( k ) = 0 end if end do end subroutine get_model_space subroutine bbsort ( a , mm , nn ) implicit none real :: a ( * ), d integer :: mm , nn , m , j , i m = nn - mm + 1 do while ( m . gt . 0 ) ! 10      if (m .gt. 0) then j = m + mm - 2 m = 0 do i = mm , j if ( a ( i ) . gt . a ( i + 1 )) then d = a ( i ) a ( i ) = a ( i + 1 ) a ( i + 1 ) = d m = i - mm + 1 end if end do end do !        go to 10 !        end if end subroutine bbsort subroutine get_special_boundaries () implicit none integer :: nm , nn , iss , ixs , iys , ll , i_g , kxy real :: dd ( nnxy , max_seg ), aa ( nnxy , max_seg ) ! !  special boundary ! open ( 12 , file = 'bound.special' ) read ( 12 , * ) nm do nn = 1 , nm read ( 12 , * ) iss , ixs , iys ll = 0 do i_g = 1 , iss - 1 ll = ll + nxs_sub ( i_g ) * nys_sub ( i_g ) end do kxy = ixs + ( iys - 1 ) * nxs_sub ( iss ) ll = ll + ixs + ( iys - 1 ) * nxs_sub ( iss ) np ( 4 * ( ll - 1 ) + 1 ) = 2 dp ( 4 * ( ll - 1 ) + 1 ) = 10 beg ( 4 * ( 11 - 1 ) + 1 ) = 1 dd ( kxy , iss ) = beg ( 4 * ( ll - 1 ) + 1 ) np ( 4 * ( ll - 1 ) + 2 ) = 2 aa ( kxy , iss ) = beg ( 4 * ( ll - 1 ) + 2 ) np ( 4 * ( ll - 1 ) + 3 ) = 2 np ( 4 * ( ll - 1 ) + 4 ) = 2 end do close ( 12 ) end subroutine get_special_boundaries subroutine subfault_positions () !! !!  We detect adjacent subfaults and their relative location !! implicit none integer k , nn_use integer n_is integer ix , iy , nxx , nyy , io_change character ( len = 80 ) aaaa integer i_s do i_s = 1 , n_seg do ix = 1 , nxs_sub ( i_s ) do iy = 1 , nys_sub ( i_s ) nup ( 1 , iy , ix , i_s ) = i_s nup ( 2 , iy , ix , i_s ) = ix nup ( 3 , iy , ix , i_s ) = iy - 1 ndown ( 1 , iy , ix , i_s ) = i_s ndown ( 2 , iy , ix , i_s ) = ix ndown ( 3 , iy , ix , i_s ) = iy + 1 nleft ( 1 , iy , ix , i_s ) = i_s nleft ( 2 , iy , ix , i_s ) = ix - 1 nleft ( 3 , iy , ix , i_s ) = iy nright ( 1 , iy , ix , i_s ) = i_s nright ( 2 , iy , ix , i_s ) = ix + 1 nright ( 3 , iy , ix , i_s ) = iy end do end do end do open ( 22 , file = \"continue\" ) do I_s = 1 , n_seg ! read ( 22 , * ) read ( 22 , * ) n_is , nyy do ix = 1 , nxs_sub ( I_s ) nup ( 1 , 1 , ix , I_s ) = n_is nup ( 2 , 1 , ix , I_s ) = ix nup ( 3 , 1 , ix , I_s ) = nyy end do !       n read ( 22 , * ) n_is , nyy nn_use = nys_sub ( i_s ) do ix = 1 , nxs_sub ( I_s ) ndown ( 1 , nn_use , ix , I_s ) = n_is ndown ( 2 , nn_use , ix , i_s ) = ix ndown ( 3 , nn_use , ix , i_s ) = nyy end do !       t read ( 22 , * ) n_is , nxx do iy = 1 , nys_sub ( I_s ) nleft ( 1 , iy , 1 , I_s ) = n_is nleft ( 2 , iy , 1 , i_s ) = nxx nleft ( 3 , iy , 1 , i_s ) = iy end do !       ht read ( 22 , * ) n_is , nxx nn_use = nxs_sub ( i_s ) do iy = 1 , nys_sub ( I_s ) nright ( 1 , iy , nn_use , i_s ) = n_is nright ( 2 , iy , nn_use , i_s ) = nxx nright ( 3 , iy , nn_use , i_s ) = iy end do end do close ( 22 ) open ( 22 , file = \"continue.special\" ) read ( 22 , * ) nn_use do k = 1 , nn_use read ( 22 , '(a)' ) aaaa ! 1  format(a) write ( * , '(a)' ) aaaa read ( 22 , * ) i_s , ix , iy read ( 22 , * ) io_change , n_is , nxx , nyy if ( io_change . eq . 1 ) then nup ( 1 , iy , ix , i_s ) = n_is nup ( 2 , iy , ix , i_s ) = nxx nup ( 3 , iy , ix , i_s ) = nyy end if read ( 22 , * ) io_change , n_is , nxx , nyy if ( io_change . eq . 1 ) then ndown ( 1 , iy , ix , i_s ) = n_is ndown ( 2 , iy , ix , i_s ) = nxx ndown ( 3 , iy , ix , i_s ) = nyy end if read ( 22 , * ) io_change , n_is , nxx , nyy if ( io_change . eq . 1 ) then nleft ( 1 , iy , ix , i_s ) = n_is nleft ( 2 , iy , ix , i_s ) = nxx nleft ( 3 , iy , ix , i_s ) = nyy end if read ( 22 , * ) io_change , n_is , nxx , nyy if ( io_change . eq . 1 ) then nright ( 1 , iy , ix , i_s ) = n_is nright ( 2 , iy , ix , i_s ) = nxx nright ( 3 , iy , ix , i_s ) = nyy end if end do close ( 22 ) end subroutine subfault_positions end module model_parameters","title":"model_parameters.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/run_modelling_save.f95.html","text":"Contents Programs run_modelling Source Code run_modelling_save.f95 Source Code program run_modelling use constants , only : max_seg , nt1 , nnxy use model_parameters , only : get_faults_data , get_model_space , get_special_boundaries , subfault_positions , & & write_model use modelling_inputs , only : get_annealing_param , n_iter , io_re , cooling_rate , t_stop , t_mid , t0 use get_stations_data , only : get_data use retrieve_gf , only : get_gf use save_forward , only : write_forward use rise_time , only : get_source_fun use annealing , only : initial_model , initial_regularization , annealing_iter implicit none integer :: io_data2 , i real :: dd ( nnxy , max_seg ), aa ( nnxy , max_seg ), tt ( nnxy , max_seg ), tl ( nnxy , max_seg ) real :: tr ( nnxy , max_seg ) real :: er , t io_data2 = 3 call get_annealing_param () call get_faults_data () call get_model_space () call get_special_boundaries () call subfault_positions () call get_gf ( io_data2 ) call get_data ( io_data2 ) call get_source_fun () call initial_model ( dd , aa , tt , tl , tr ) call initial_regularization ( dd , aa , tt , tl , tr ) t = t_mid if ( io_re . eq . 0 ) t = t0 do i = 1 , n_iter call annealing_iter ( dd , aa , tt , tl , tr , er , t ) write ( * , * ) 'iter: ' , i if ( t . lt . t_stop ) then t = t * 0.995 else t = t * cooling_rate endif enddo call write_forward ( dd , aa , tt , tl , tr , io_data2 ) call write_model ( dd , aa , tt , tl , tr ) end program run_modelling","title":"run_modelling_save.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/misfit_eval.f95.html","text":"Contents Modules misfit_eval Source Code misfit_eval.f95 Source Code module misfit_eval use constants , only : inptd use wavelet_param , only : lnpt , jmin , jmax , jfmax , nlen use get_stations_data , only : weight , wave_obs , wmax , misfit_type , t_max , wavelet_weight implicit none contains pure subroutine misfit ( nf , wave_syn , error ) !! !!   Misfit between observed and synthetic waveforms, in wavelet domain. !! real , intent ( inout ) :: wave_syn ( inptd ) integer , intent ( in ) :: nf real , intent ( out ) :: error real * 8 :: aa , ab , bb , er , er1 , er2 , erp , error2 real :: ramp integer :: i , j , k , n1 , n2 , n_be , n_begin , n_delt , n_ed ! error2 = 0.d0 ramp = wmax ( nf ) n1 = 2 ** ( jmin - 1 ) n2 = 2 ** ( jmax ) - 1 do i = n1 , n2 wave_syn ( i ) = wave_syn ( i ) / ramp end do !   ramp = 1 do j = jmin , jmax er = 0.d0 if ( misfit_type ( j , nf ) . eq . 0 ) cycle if ( wavelet_weight ( j , nf ) . lt . 1.0e-5 ) cycle n_begin = 2 ** ( j - 1 ) n_delt = nlen / n_begin n_be = n_begin n_ed = n_begin + int ( t_max ( nf ) / n_delt + 0.5 ) - 1 if ( n_ed . lt . n_be ) n_ed = n_be !  j = 1 L1 Norm if ( misfit_type ( j , nf ) . eq . 1 ) then do k = n_be , n_ed er = er + abs ( wave_syn ( k ) - wave_obs ( k , nf )) end do er = wavelet_weight ( j , nf ) * ( er / ( n_ed - n_be + 1 )) error2 = error2 + er end if !       j = 2 L2 norm if ( misfit_type ( j , nf ) . eq . 2 ) then do k = n_be , n_ed erp = wave_syn ( k ) - wave_obs ( k , nf ) er = er + erp * erp end do er = wavelet_weight ( j , nf ) * sqrt ( er / ( n_ed - n_be + 1 )) error2 = error2 + er end if !       j = 3 L1+L2 Norm if ( misfit_type ( j , nf ) . eq . 3 ) then er1 = 0.d0 er2 = 0.d0 do k = n_be , n_ed erp = abs ( wave_syn ( k ) - wave_obs ( k , nf )) er1 = er1 + erp er2 = er2 + erp * erp end do er = wavelet_weight ( j , nf ) & & * ( 0.5d0 * sqrt ( er2 / ( n_ed - n_be + 1 )) + 0.5d0 * er1 / ( n_ed - n_be + 1 )) error2 = error2 + er end if !     j = 4 correlation if ( misfit_type ( j , nf ) . eq . 4 ) then ab = 0.d0 aa = 0.d0 bb = 0.d0 do k = n_be , n_ed ab = wave_syn ( k ) * wave_obs ( k , nf ) + ab aa = wave_syn ( k ) * wave_syn ( k ) + aa bb = wave_obs ( k , nf ) * wave_obs ( k , nf ) + bb end do er = wavelet_weight ( j , nf ) * ( 1.d0 - 2.d0 * ab / ( aa + bb )) error2 = error2 + er end if end do error2 = error2 / ( jmax - jmin + 1 ) error2 = error2 * weight ( nf ) error = real ( error2 ) end subroutine misfit end module misfit_eval","title":"misfit_eval.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/geodesics.f95.html","text":"Contents Modules geodesics Source Code geodesics.f95 Source Code module geodesics ! ! module with routines to compute distance, azimuth, back-azimuth between 2 points on the earth surface ! use constants , only : pi implicit none real * 8 , private :: c0 , c2 , c4 real * 8 , parameter , private :: rad = 637 8.155d0 , gl = . 99327733 d0 , ec = 0.672267002d-2 real * 8 , parameter , private :: const = 5 7.2957795d0 real * 8 , private :: th ( 2 ), phi ( 2 ), xdeg ( 2 ), azinv ( 2 ), dist ( 2 ), az ( 2 ) public :: distaz private :: disaz1 , arc_dist contains subroutine distaz ( lat_sta , lon_sta , lat_e , lon_e , dis , azz , baz ) implicit none real , intent ( in ) :: lat_sta , lon_sta , lat_e , lon_e real * 8 , intent ( out ) :: dis , azz , baz if ( abs ( lat_sta - lat_e ) . gt . 1.0e-5 . or . abs ( lon_sta - lon_e ) . gt . 1.e-5 ) then th ( 1 ) = lat_sta th ( 2 ) = lat_e phi ( 1 ) = lon_sta phi ( 2 ) = lon_e call disaz1 ( 1 , 2 ) azz = az ( 1 ) baz = azinv ( 1 ) dis = dist ( 1 ) else dis = 0.d0 azz = 0.d0 baz = 18 0.d0 end if end subroutine distaz subroutine disaz1 ( n , k ) implicit none integer , intent ( in ) :: n , k integer :: i real * 8 :: sink , cosk , tank , sini , cosi , tani real * 8 :: a , b , c , a1 , b1 , c1 , sc , sd1 , sd , arg real * 8 :: el , x , cdl , sdl , dum , a12 , dum1 , cs12 real * 8 :: v1 , v2 , z1 , z2 , x2 , y2 , chck , u1 , u2 , b0 real * 8 :: test1 , test2 , test3 , coeff1 , coeff2 , coeff3 real * 8 :: al12 , al21 , eo th (:) = th (:) / const phi (:) = phi (:) / const sink = dsin ( th ( k )) cosk = dcos ( th ( k )) tank = sink / cosk arg = datan ( gl * tank ) c = dsin ( arg ) a = dcos ( arg ) * dcos ( phi ( k )) b = dcos ( arg ) * dsin ( phi ( k )) do i = 1 , n sini = dsin ( th ( i )) cosi = dcos ( th ( i )) tani = sini / cosi arg = datan ( gl * tani ) C1 = dsin ( arg ) A1 = dcos ( arg ) * dcos ( phi ( i )) B1 = dcos ( arg ) * dsin ( phi ( i )) sc = a * a1 + b * b1 + c * c1 sd1 = ( a - a1 ) ** 2 + ( b - b1 ) ** 2 + ( c - c1 ) ** 2 sd = ( a + a1 ) ** 2 + ( b + b1 ) ** 2 + ( c + c1 ) ** 2 sd = dsqrt ( sd1 * sd / 4.d0 ) xdeg ( i ) = datan ( sd / sc ) * const if ( sc . lt . 0 ) xdeg ( i ) = xdeg ( i ) + 18 0.d0 el = ec / ( 1.d0 - ec ) x = ( 1.d0 + el + tani ** 2 ) / ( 1.d0 + el + TANK ** 2 ) CDL = dcos ( phi ( i ) - phi ( k )) SDL = dsin ( phi ( i ) - phi ( k )) al12 = tani / ( 1.d0 + el ) / tank + ec * dsqrt ( x ) - cdl al21 = tank / ( 1.d0 + el ) / tani + ec * dsqrt ( 1.d0 / x ) - cdl DUM = sink * al12 A12 = datan ( sdl / dum ) DUM1 = sini * al21 az ( i ) = A12 * const azinv ( i ) = datan ( - sdl / dum1 ) * const if ( sdl . lt . 0 ) then if ( dum . lt . 0 ) az ( i ) = az ( i ) - 18 0.d0 else if ( dum . lt . 0 ) az ( i ) = 18 0.d0 + az ( i ) end if if ( - sdl . lt . 0 ) then if ( dum1 . lt . 0 ) azinv ( i ) = azinv ( i ) - 18 0.d0 else if ( dum1 . lt . 0 ) azinv ( i ) = azinv ( i ) + 18 0.d0 end if if ( az ( i ) . lt . 0.0 ) az ( i ) = 36 0.d0 + az ( i ) if ( azinv ( i ) . lt . 0.0 ) azinv ( i ) = 36 0.d0 + azinv ( i ) cs12 = dcos ( a12 ) th ( i ) = th ( i ) * const phi ( i ) = phi ( i ) * const eo = EL * (( COSK * CS12 ) ** 2 + SINK ** 2 ) c0 = 1.d0 + eo / 4.d0 - 3.d0 * eo ** 2 / 6 4.d0 + 5.d0 * eo ** 3 / 25 6.d0 c2 = - eo / 8.d0 + eo ** 2 / 3 2.d0 - 1 5.d0 * eo ** 3 / 102 4.d0 c4 = - eo ** 2 / 25 6.d0 + 3.d0 * eo ** 3 / 102 4.d0 V1 = rad / dsqrt ( 1.d0 - ec * sink ** 2 ) V2 = rad / dsqrt ( 1.d0 - ec * sini ** 2 ) Z1 = V1 * ( 1.d0 - EC ) * SINK Z2 = V2 * ( 1.d0 - EC ) * SINI X2 = V2 * COSI * CDL Y2 = V2 * COSI * SDL chck = xdeg ( i ) * 11 1.32d0 arg = TANK / CS12 / dsqrt ( 1.d0 + EO ) u1 = datan ( arg ) X = ( X2 * CS12 - Y2 * SINK * dsin ( A12 )) * dsqrt ( 1.d0 + EO ) arg = ( V1 * SINK + ( 1.d0 + EO ) * ( Z2 - Z1 )) / X u2 = datan ( arg ) x = 1.d0 + EL * ( COSK * CS12 ) ** 2 b0 = V1 * dsqrt ( x ) / ( 1.d0 + EO ) coeff1 = arc_dist ( b0 , u1 , u2 ) test1 = abs ( chck - abs ( coeff1 )) coeff2 = arc_dist ( b0 , u1 , u2 + pi ) test2 = abs ( chck - abs ( coeff2 )) coeff3 = arc_dist ( b0 , u1 , u2 - pi ) test3 = abs ( chck - abs ( coeff3 )) if ( test1 . lt . 30 ) then dist ( i ) = abs ( coeff1 ) elseif ( test2 . lt . 30 ) then dist ( i ) = abs ( coeff2 ) elseif ( test3 . lt . 30 ) then dist ( i ) = abs ( coeff3 ) else dist ( i ) = chck end if end do end subroutine disaz1 function arc_dist ( b , u , s ) result ( dist ) implicit none real * 8 :: b , u , s , dist , x , sinu2 , sinu4 , sins2 , sins4 sinu2 = dsin ( 2.d0 * u ) sinu4 = dsin ( 4.d0 * u ) sins2 = dsin ( 2.d0 * s ) sins4 = dsin ( 4.d0 * s ) x = c0 * ( u - s ) + c2 * ( sinu2 - sins2 ) + c4 * ( sinu4 - sins4 ) dist = b * x end function arc_dist end module geodesics","title":"geodesics.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/regularization.f95.html","text":"Contents Modules regularization Source Code regularization.f95 Source Code module regularization use constants , only : max_seg , nnxy , dpi use model_parameters , only : nxs_sub , nys_sub , nleft , nright , nup , ndown , rake_min , n_seg implicit none real :: slip_field ( nnxy , max_seg , 2 ) integer :: nnn , nxys ( max_seg ) contains subroutine define_slip_field ( slip , rake ) !! !!   Initialize slip vector field !! implicit none real , intent ( in ) :: slip ( nnxy , max_seg ), rake ( nnxy , max_seg ) real angle integer i_s , i ! !  we define the slip vector field ! nnn = 0 do i_s = 1 , n_seg nxys ( i_s ) = nxs_sub ( i_s ) * nys_sub ( i_s ) do i = 1 , nxys ( i_s ) angle = ( rake ( i , i_s ) - rake_min ) * dpi slip_field ( i , i_s , 1 ) = slip ( i , i_s ) * cos ( angle ) slip_field ( i , i_s , 2 ) = slip ( i , i_s ) * sin ( angle ) end do nnn = nnn + nxys ( i_s ) end do end subroutine define_slip_field subroutine modify_slip_field ( nn_sub , d_sub , a_sub ) !! !!   Modify slip vector field !! implicit none integer , intent ( in ) :: nn_sub real , intent ( in ) :: d_sub , a_sub integer n_total , ll_s real angle integer i_s , i_ss n_total = 0 do i_ss = 1 , n_seg n_total = nxys ( i_ss ) + n_total if ( nn_sub . le . n_total ) then i_s = i_ss ll_s = nn_sub exit end if end do do i_ss = 1 , i_s - 1 ll_s = ll_s - nxys ( i_ss ) end do angle = ( a_sub - rake_min ) * dpi slip_field ( ll_s , i_s , 1 ) = d_sub * cos ( angle ) slip_field ( ll_s , i_s , 2 ) = d_sub * sin ( angle ) end subroutine modify_slip_field subroutine lap ( err ) !! !!   Laplacian regularization of slip vector field !! implicit none real , intent ( out ) :: err integer n_sub integer n_is , ll integer nxx , nyy , jj , nx , ny real d1 , d2 , d3 , d4 , error !, kahan_y, kahan_t, kahan_c real ( 8 ) :: err2 integer i_s err2 = 0.d0 !   kahan_y = 0.0 !   kahan_t = 0.0 !   kahan_c = 0.0 do jj = 1 , 2 do i_s = 1 , n_seg do n_sub = 1 , nxys ( i_s ) ny = int ( n_sub / nxs_sub ( i_s )) + 1 nx = n_sub - ( ny - 1 ) * nxs_sub ( i_s ) if ( nx . eq . 0 ) then nx = nxs_sub ( i_s ) ny = ny - 1 end if !                 write(*,*)\"i_s\", i_s, nx, ny, n_sub, jj !       left n_is = nleft ( 1 , ny , nx , i_s ) nxx = nleft ( 2 , ny , nx , i_s ) nyy = nleft ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d1 = 0.0 else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d1 = slip_field ( ll , n_is , jj ) end if !        write(*,*) n_is, nxx, nyy, ll,\"left\" !       right n_is = nright ( 1 , ny , nx , i_s ) nxx = nright ( 2 , ny , nx , i_s ) nyy = nright ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d3 = 0.0 else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d3 = slip_field ( ll , n_is , jj ) end if !        write(*,*) n_is, nxx, nyy, ll,\"right\" !       up n_is = nup ( 1 , ny , nx , i_s ) nxx = nup ( 2 , ny , nx , i_s ) nyy = nup ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d2 = 0.0 else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d2 = slip_field ( ll , n_is , jj ) end if !                    write(*,*) n_is, nxx, nyy, ll,\"up\" !       down n_is = ndown ( 1 , ny , nx , i_s ) nxx = ndown ( 2 , ny , nx , i_s ) nyy = ndown ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d4 = 0.0 else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d4 = slip_field ( ll , n_is , jj ) end if !                   write(*,*) n_is, nxx, nyy, ll,\"down\" ! error = slip_field ( n_sub , i_s , jj ) - 0.25 * ( d1 + d2 + d3 + d4 ) error = error * error err2 = err2 + error !            kahan_y = error-kahan_c !            kahan_t = err+kahan_y !            kahan_c = (kahan_t-err)-kahan_y !            err = kahan_t end do end do end do err2 = sqrt ( err2 / nnn ) err = real ( err2 ) end subroutine lap pure subroutine tlap ( tt , err ) !! !!   Laplacian regularization of rupture initiation time !! implicit none real , intent ( in ) :: tt ( nnxy , max_seg ) real , intent ( out ) :: err integer n_sub integer n_is integer nxx , nyy , nx , ny real d1 , d2 , d3 , d4 , error !, kahan_y, kahan_t, kahan_c real ( 8 ) :: err2 integer i_s , ll err2 = 0.d0 !   kahan_y = 0.0 !   kahan_c = 0.0 !   kahan_t = 0.0 !   err = 0.0 do i_s = 1 , n_seg do n_sub = 1 , nxys ( i_s ) ny = int ( n_sub / nxs_sub ( i_s )) + 1 nx = n_sub - ( ny - 1 ) * nxs_sub ( i_s ) if ( nx . eq . 0 ) then nx = nxs_sub ( i_s ) ny = ny - 1 end if !       left n_is = nleft ( 1 , ny , nx , i_s ) nxx = nleft ( 2 , ny , nx , i_s ) nyy = nleft ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d1 = tt ( n_sub , i_s ) else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d1 = tt ( ll , n_is ) end if !       right n_is = nright ( 1 , ny , nx , i_s ) nxx = nright ( 2 , ny , nx , i_s ) nyy = nright ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d3 = tt ( n_sub , i_s ) else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d3 = tt ( ll , n_is ) end if !       up n_is = nup ( 1 , ny , nx , i_s ) nxx = nup ( 2 , ny , nx , i_s ) nyy = nup ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d2 = tt ( n_sub , i_s ) else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d2 = tt ( ll , n_is ) end if !       down n_is = ndown ( 1 , ny , nx , i_s ) nxx = ndown ( 2 , ny , nx , i_s ) nyy = ndown ( 3 , ny , nx , i_s ) if ( n_is . eq . 0 ) then d4 = tt ( n_sub , i_s ) else ll = nxx + ( nyy - 1 ) * nxs_sub ( n_is ) d4 = tt ( ll , n_is ) end if error = tt ( n_sub , i_s ) - 0.25 * ( d1 + d2 + d3 + d4 ) error = error * error err2 = err2 + error !         kahan_y = error-kahan_c !         kahan_t = err+kahan_y !         kahan_c = (kahan_t-err)-kahan_y !         err = kahan_t end do end do err2 = sqrt ( err2 / nnn ) err = real ( err2 ) end subroutine tlap end module regularization","title":"regularization.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/modelling_inputs.f95.html","text":"Contents Modules modelling_inputs Source Code modelling_inputs.f95 Source Code module modelling_inputs implicit none integer :: idum , io_data , n_iter real :: t0 , cooling_rate , t_stop , emin , smooth_moment , smooth_slip , smooth_time real :: t_mid , t_latest , cm_point integer :: io_re , io_func , io contains subroutine get_annealing_param () implicit none open ( 10 , file = 'HEAT.IN' ) read ( 10 , * ) n_iter , idum , io_data , cm_point read ( 10 , * ) t0 , cooling_rate , t_stop , emin , smooth_moment , smooth_slip , smooth_time read ( 10 , * ) io_re , t_mid , io_func , t_latest read ( 10 , * ) io close ( 10 ) end subroutine get_annealing_param end module modelling_inputs","title":"modelling_inputs.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/save_forward.f95.html","text":"Contents Modules save_forward Source Code save_forward.f95 Source Code module save_forward use constants , only : max_seg , nnxy , inptd , npth , nnsta , n_data , nnpxy , twopi , & & nnpy , nnys , npuse , pi , mmsou , dpi use model_parameters , only : nxs_sub , nys_sub , ta0 , dta , msou , n_seg , dxs , dys , & & nx_p , ny_p use wavelet_param , only : lnpt , jfmax , nlen use get_stations_data , only : dt_channel use retrieve_gf , only : green_stk , green_dip use rise_time , only : source , fourier_asym_cosine , realtr , fft use modelling_inputs , only : get_annealing_param implicit none integer , parameter :: nnsta_tele = 80 contains subroutine write_forward ( slip , rake , rupt_time , tl , tr , strong , cgps , body , surf , dart ) !! !!  We save the forward solution given a kinematic model, for all specified !!  data types. !! implicit none integer ll_in , ll_out logical :: strong , cgps , body , surf , dart real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), tr ( nnxy , max_seg ), & & tl ( nnxy , max_seg ), erm , ermin complex z0 ! z0 = cmplx ( 0.0 , 0.0 ) erm = 0.0 ll_in = 0 ll_out = 0 ermin = 1.0e+10 write ( * , * ) dxs , dys if ( strong ) then call write_strong_motion_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) ll_in = ll_out end if if ( cgps ) then call write_cgps_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) ll_in = ll_out end if if ( body ) then call write_body_waves_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) ll_in = ll_out end if if ( surf ) then call write_surface_waves_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) ll_in = ll_out end if if ( dart ) then call write_dart_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) ll_in = ll_out end if !   select case (io_data) !      case (1) !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (2) !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (3) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (4) !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         lL_in = ll_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (5) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (6) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (7) !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (8) !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (9) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (10) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = lL_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (11) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (12) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (13) !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         lL_in = ll_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (14) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !      case (15) !         call write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !         ll_in = ll_out !         call write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) !   endselect end subroutine write_forward subroutine write_strong_motion_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , isl , isr , ll , ir_max , int1 , int2 , int3 , & & jf , i , k , ll_s , i_s , ir , n_chan , ixs , iys , n_chan3 real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), & & cr ( inptd ), cz ( inptd ), r , t1 , t2 , time , a , b , ww , float1 , float2 , float3 ,& & dt , rake2 , umax , df complex forward ( inptd ), z0 , z complex :: source2 ( npth , mmsou , mmsou ) character ( len = 6 ) sta_name ( nnsta ) character ( len = 3 ) component ( nnsta ), comp z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 open ( 9 , file = 'Readlp.inf' , status = 'old' ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) ir_max , n_chan read ( 9 , * ) do ir = 1 , ir_max read ( 9 , * ) int1 , sta_name ( ir ), float1 , float2 , int2 , component ( ir ), float3 , int3 end do close ( 9 ) ! !       make the rise time function ! dt = dt_channel ( ll_in + 1 ) jf = 2 ** ( lnpt - 1 ) + 1 df = 1.0 / ( 2 ** lnpt ) / dt open ( 120 , file = 'Source_function' ) do isl = 1 , msou do isr = 1 , msou cr (:) = 0.0 cz (:) = 0.0 t1 = ta0 + ( isl - 1 ) * dta t2 = ta0 + ( isr - 1 ) * dta r = t1 + t2 k = int ( r / dt + 0.5 ) + 1 do i = 1 , k time = ( i - 1 ) * dt if ( time . lt . t1 ) then cr ( i ) = ( 1.0 - cos ( 2 * pi * time / ( 2 * t1 ))) / r else cr ( i ) = ( 1.0 + cos ( 2 * pi * ( time - t1 ) / ( 2 * t2 ))) / r end if end do write ( 120 , * ) 'k: ' , k write ( 120 , * ) '(t1, t2): ' , t1 , t2 write ( 120 , * ) 'STF: ' , ( cr ( i ), i = 1 , 512 ) CALL FFT ( CR , CZ , LNPT , - 1. ) do i = 1 , jf write ( 120 , * ) 'freq: ' , ( i - 1 ) * df write ( 120 , * ) 'F[STF]: ' , ( cmplx ( cr ( i ), cz ( i ))) * dt call fourier_asym_cosine (( i - 1 ) * df , t1 , t2 , source2 ( i , isl , isr )) !                SOURCE(i, ISL, isr) = CMPLX(CR(i), CZ(i))*dt write ( 120 , * ) 'F[STF]: ' , source2 ( i , isl , isr ) end do end do end do close ( 120 ) ! !  end of rise time ! open ( 18 , file = 'synm.str' ) k = 0 ! !  set up the green function for every subfault !  and calculate the initial value of objective function ! do ir = 1 , n_chan comp = component ( ir ) ll_g = ir + ll_in do i = 1 , npth forward ( i ) = z0 end do ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) do i = 1 , nlen ww = - ( i - 1 ) * twopi * df * rupt_time ( ll_s , i_s ) z = cmplx ( cos ( ww ), sin ( ww )) forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ll_g , ll ) + b * green_stk ( i , ll_g , ll )) * source2 ( i , isl , isr ) * z end do end do end do end do do i = 1 , jf if ( i . le . jfmax ) then cr ( i ) = real ( forward ( i )) cz ( i ) = aimag ( forward ( i )) else cr ( i ) = 0.0 cz ( i ) = 0.0 end if end do call realtr ( cr , cz , lnpt ) call fft ( cr , cz , lnpt , 1. ) umax = 0.0 if ( comp . eq . 'HNZ' ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'HNZ' if ( comp . eq . 'HNN' ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'HNN' if ( comp . eq . 'HNE' ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'HNE' do k = 1 , nlen write ( 18 , * ) cr ( k ), cz ( k ) end do end do close ( 18 ) ll_out = ll_out + n_chan end subroutine write_strong_motion_forward subroutine write_cgps_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , isl , isr , ll , n_chan3 , int1 , int2 , int3 , & & jf , i , k , ll_s , i_s , ir , n_chan , ixs , iys , ir_max real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), cr ( inptd ), cz ( inptd ), t1 , t2 , a , & & b , ww , dt , rake2 , df , float1 , float2 , float3 complex forward ( inptd ), z0 , z complex :: source2 ( npth , mmsou , mmsou ) character ( len = 6 ) sta_name ( nnsta ) character ( len = 3 ) component ( nnsta ), comp z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 open ( 9 , file = 'Readlp.cgps' , status = 'old' ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) ir_max , n_chan read ( 9 , * ) do ir = 1 , ir_max read ( 9 , * ) int1 , sta_name ( ir ), float1 , float2 , int2 , component ( ir ), float3 , int3 end do close ( 9 ) ! !       make the rise time function ! dt = dt_channel ( ll_in + 1 ) jf = 2 ** ( lnpt - 2 ) + 1 df = 1.0 / ( 2 ** lnpt ) / dt do isl = 1 , msou do isr = 1 , msou t1 = ta0 + ( isl - 1 ) * dta t2 = ta0 + ( isr - 1 ) * dta if ( t1 . lt . dt ) t1 = dt if ( t2 . lt . dt ) t2 = dt do i = 1 , jf call fourier_asym_cosine (( i - 1 ) * df , t1 , t2 , source2 ( i , isl , isr )) end do end do end do ! !  end of rise time ! open ( 18 , file = 'synm.cgps' ) k = 0 ! !  set up the green function for every subfault !  and calculate the initial value of objective function ! do ir = 1 , n_chan comp = component ( ir ) ll_g = ir + ll_in do i = 1 , npth cr ( i ) = 0.0 cz ( i ) = 0.0 forward ( i ) = z0 end do ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) do i = 1 , nlen ww = - ( i - 1 ) * twopi * df * rupt_time ( ll_s , i_s ) z = cmplx ( cos ( ww ), sin ( ww )) forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ll_g , ll ) + b * green_stk ( i , ll_g , ll )) * source2 ( i , isl , isr ) * z end do end do end do end do do i = 1 , jf cr ( i ) = real ( forward ( i )) cz ( i ) = aimag ( forward ( i )) end do call realtr ( cr , cz , lnpt ) call fft ( cr , cz , lnpt , 1. ) if ( comp . eq . 'LXZ' ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'LXZ' if ( comp . eq . 'LXN' ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'LXN' if ( comp . eq . 'LXE' ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'LXE' do k = 1 , nlen write ( 18 , * ) cr ( k ), cz ( k ) end do end do close ( 18 ) ll_out = ll_out + n_chan end subroutine write_cgps_forward subroutine write_body_waves_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) implicit none integer nnn , i_seg , nxy , nstaon , ir , ll_g , k , & & ll , i_s , iys , jf , i , npxy , ll_s , kxy , ixs , & & isl , isr , nl , llove ( nnsta_tele ), int1 , int2 , & & nxys ( max_seg ), ll_in , ll_out , n_chan3 real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), t1 , t2 , & & dt , df , ddelt , azim , w , cr ( inptd ), cz ( inptd ), sinal , cosal , & & float1 , float2 , float3 , float4 , float5 , float6 , float7 complex :: z , z0 , forward ( npth ) complex :: source2 ( npth , mmsou , mmsou ) ! character ( len = 6 ) STNAME ( nnsta_tele ), string1 , string2 , string3 ! open ( 9 , file = 'Readlp.das' , status = 'old' ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) nstaon do ir = 1 , nstaon read ( 9 , * ) int1 , string1 , string2 , stname ( ir ), string3 , & & float1 , float2 , float3 , float3 , float4 , float5 , int2 , float6 , float7 , llove ( ir ) end do close ( 9 ) z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 nnn = 0 do i_seg = 1 , n_seg nxy = nxs_sub ( i_seg ) * nys_sub ( i_seg ) nxys ( i_seg ) = nxy nnn = nnn + nxy end do dt = dt_channel ( ll_in + 1 ) jf = 2 ** ( lnpt - 1 ) + 1 df = 1.0 / ( 2 ** lnpt ) / dt do isl = 1 , msou do isr = 1 , msou t1 = ta0 + ( isl - 1 ) * dta t2 = ta0 + ( isr - 1 ) * dta if ( t1 . lt . dt ) t1 = dt if ( t2 . lt . dt ) t2 = dt do i = 1 , 2 * jfmax call fourier_asym_cosine (( i - 1 ) * df , t1 , t2 , source2 ( i , isl , isr )) end do end do end do ! !  End of Rise Time ! OPEN ( 18 , FILE = 'synm.tele' ) k = 0 ! !  Now, we compute the synthetic seismographs ! npxy = nx_p * ny_p do ir = 1 , nstaon ll_g = ll_in + ir do i = 1 , npth forward ( i ) = z0 end do LL = 0 ddelt = 0.0 do i_s = 1 , n_seg kxy = 0 do iys = 1 , nys_sub ( i_s ) do ixs = 1 , NXS_sub ( i_s ) kxy = kxy + 1 LL = LL + 1 azim = rake ( kxy , i_s ) * dpi sinal = sin ( azim ) * slip ( kxy , i_s ) cosal = cos ( azim ) * slip ( kxy , i_s ) ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs isl = int (( tl ( kxy , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( kxy , i_s ) - ta0 ) / dta + 0.5 ) + 1 do i = 1 , 2 * jfmax w = - ( i - 1 ) * twopi * df * rupt_time ( kxy , i_s ) z = cmplx ( cos ( w ), sin ( w )) forward ( i ) = forward ( i )& & + ( sinal * green_dip ( i , ll_g , ll ) + cosal * green_stk ( i , ll_g , ll )) * source2 ( i , Isl , isr ) * z end do end do end do end do do i = 1 , jf if ( i . le . jfmax ) then cr ( i ) = real ( forward ( i )) cz ( i ) = aimag ( forward ( i )) else cr ( i ) = 0.0 cz ( i ) = 0.0 end if end do call realtr ( cr , cz , lnpt ) call fft ( cr , cz , lnpt , 1.0 ) nl = 2 ** lnpt if ( llove ( ir ) . eq . 0 ) then write ( 18 , * ) nl , dt , stname ( ir ), 'P' else write ( 18 , * ) nl , dt , stname ( ir ), 'SH' end if do i = 1 , nl write ( 18 , * ) cr ( i ), cz ( i ) end do end do ! close ( 18 ) ll_out = ll_in + nstaon end subroutine write_body_waves_forward subroutine write_surface_waves_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) implicit none integer ll_in , ll_out , ir_max , & & ll_g , isl , isr , ll , jf , i , k , ll_s , i_s , ir , n_chan , & & iys , ixs , io_up ( nnsta ), int1 , int2 real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), & & cr ( inptd ), cz ( inptd ), t1 , t2 , a , b , ww , dt , rake2 , umax , df , float1 , float2 complex z0 , forward ( inptd ), z complex :: source2 ( npth , mmsou , mmsou ) character ( len = 6 ) sta_name ( nnsta ) z0 = cmplx ( 0.0 , 0.0 ) open ( 9 , file = 'Readlp.inf_low' , status = 'old' ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) ir_max , n_chan write ( * , * ) n_chan read ( 9 , * ) do ir = 1 , ir_max read ( 9 , * ) int1 , sta_name ( ir ), float1 , float2 , int2 , io_up ( ir ) end do close ( 9 ) ! ! suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 ! subfault is 3e+21. The gf is for Mo = 1e+20 dyne.cm ! the unit of surface wave is mm. ! !       make the rise time function ! dt = dt_channel ( ll_in + 1 ) jf = 2 ** ( lnpt - 1 ) + 1 df = 1.0 / ( 2 ** lnpt ) / 4.0 do isl = 1 , msou do isr = 1 , msou t1 = ta0 + ( isl - 1 ) * dta t2 = ta0 + ( isr - 1 ) * dta if ( t1 . lt . dt ) t1 = dt if ( t2 . lt . dt ) t2 = dt do i = 1 , jf call fourier_asym_cosine (( i - 1 ) * df , t1 , t2 , source2 ( i , isl , isr )) end do end do end do ! !  end of rise time ! open ( 18 , file = 'synm.str_low' ) k = 0 ! !  set up the green function for every subfault !  and calculate the initial value of objective function ! do ir = 1 , n_chan ll_g = ir + ll_in do i = 1 , npth cr ( i ) = 0.0 cz ( i ) = 0.0 forward ( i ) = z0 end do ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) do i = 1 , jfmax ww = - ( i - 1 ) * twopi * df * rupt_time ( ll_s , i_s ) z = cmplx ( cos ( ww ), sin ( ww )) forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ll_g , ll ) + b * green_stk ( i , ll_g , ll )) * source2 ( i , isl , isr ) * z end do end do end do end do do i = 1 , jfmax cr ( i ) = real ( forward ( i )) cz ( i ) = aimag ( forward ( i )) end do call realtr ( cr , cz , lnpt ) call fft ( cr , cz , lnpt , 1.0 ) umax = 0.0 if ( io_up ( ir ) . eq . 1 ) then write ( 18 , * ) nlen , dt , sta_name ( ir ), 'P' else write ( 18 , * ) nlen , dt , sta_name ( ir ), 'SH' end if do k = 1 , nlen write ( 18 , * ) cr ( k ), cz ( k ) end do end do close ( 18 ) ll_out = ll_out + n_chan end subroutine write_surface_waves_forward subroutine write_dart_forward ( slip , rake , rupt_time , tl , tr , ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , isl , isr , ll , n_chan3 , int1 , int2 , int3 , & & jf , i , k , ll_s , i_s , ir , n_chan , ixs , iys , ir_max real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), cr ( inptd ), cz ( inptd ), t1 , t2 , a , & & b , ww , dt , rake2 , df , float1 , float2 , float3 complex forward ( inptd ), z0 , z complex :: source2 ( npth , mmsou , mmsou ) character ( len = 6 ) sta_name ( nnsta ) z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 open ( 9 , file = 'Readlp.dart' , status = 'old' ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) ir_max , n_chan read ( 9 , * ) do ir = 1 , ir_max read ( 9 , * ) int1 , sta_name ( ir ), float1 , float2 , int2 , float3 , int3 end do close ( 9 ) ! !       make the rise time function ! dt = dt_channel ( ll_in + 1 ) jf = 2 ** ( lnpt - 2 ) + 1 df = 1.0 / ( 2 ** lnpt ) / dt do isl = 1 , msou do isr = 1 , msou t1 = ta0 + ( isl - 1 ) * dta t2 = ta0 + ( isr - 1 ) * dta if ( t1 . lt . dt ) t1 = dt if ( t2 . lt . dt ) t2 = dt do i = 1 , jf call fourier_asym_cosine (( i - 1 ) * df , t1 , t2 , source2 ( i , isl , isr )) end do end do end do ! !  end of rise time ! open ( 18 , file = 'synm.dart' ) k = 0 ! !  set up the green function for every subfault !  and calculate the initial value of objective function ! do ir = 1 , n_chan ll_g = ir + ll_in do i = 1 , npth cr ( i ) = 0.0 cz ( i ) = 0.0 forward ( i ) = z0 end do ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) do i = 1 , nlen ww = - ( i - 1 ) * twopi * df * rupt_time ( ll_s , i_s ) z = cmplx ( cos ( ww ), sin ( ww )) forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ll_g , ll ) + b * green_stk ( i , ll_g , ll )) * source2 ( i , isl , isr ) * z end do end do end do end do do i = 1 , jf cr ( i ) = real ( forward ( i )) cz ( i ) = aimag ( forward ( i )) end do call realtr ( cr , cz , lnpt ) call fft ( cr , cz , lnpt , 1. ) write ( 18 , * ) nlen , dt , sta_name ( ir ), 'dart' do k = 1 , nlen write ( 18 , * ) cr ( k ), cz ( k ) end do end do close ( 18 ) ll_out = ll_out + n_chan end subroutine write_dart_forward end module save_forward","title":"save_forward.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/retrieve_gf.f95.html","text":"Contents Modules retrieve_gf Source Code retrieve_gf.f95 Source Code ! ! TODO: change to velocity if io_v_d = 1 ! module retrieve_gf use constants , only : npuse , nnsta , nnxy_m , nnxy , nt , nny , ndis , inptd , max_seg , & & block_far , ltde , n_data , nnpxy , nnpy , nnys , block_stg , pi , twopi , npth use model_parameters , only : point_sources , n_seg , v_ref , nxs_sub , nys_sub , delay_seg , & & dxs , dys , nx_p , ny_p , dip_seg , stk_seg , cniu use wavelets , only : fourier_coefs , meyer_yamada use retrieve_surf_gf , only : get_surf_gf_data , interp_gf , get_surf_gf , npt_bank , dt_bank use rad_pattern , only : rad_coef use geodesics , only : distaz use rise_time , only : fft implicit none integer , parameter :: nnsta_tele = 80 complex , allocatable :: green_dip (:, :, :), green_stk (:, :, :) contains subroutine get_gf ( strong , cgps , body , surf , dart ) !! !!  Here, we load into memory the green functions for each subfault, for every used station !! implicit none ! integer ll_in , ll_out logical :: strong , cgps , body , surf , dart allocate ( green_dip ( npuse , nnsta , nnxy_m )) allocate ( green_stk ( npuse , nnsta , nnxy_m )) call fourier_coefs () call meyer_yamada () ll_in = 0 ll_out = 0 if ( strong ) then call get_strong_motion_gf ( ll_in , ll_out ) ll_in = ll_out end if if ( cgps ) then call get_cgps_gf ( ll_in , ll_out ) ll_in = ll_out end if if ( body ) then call get_body_waves_gf ( ll_in , ll_out ) ll_in = ll_out end if if ( surf ) then call get_surface_waves_gf ( ll_in , ll_out ) ll_in = ll_out end if if ( dart ) then call get_dart_gf ( ll_in , ll_out ) ll_in = ll_out end if !   select case (io_data) !      case (1) !         call get_cgps_gf(ll_in, ll_out) !      case (2) !         call get_strong_motion_gf(ll_in, ll_out) !      case (3) !         call get_body_waves_gf(ll_in, ll_out) !      case (4) !         call get_strong_motion_gf(ll_in, ll_out) !         lL_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !      case (5) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !      case (6) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_gf(ll_in, ll_out) !      case (7) !         call get_strong_motion_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !      case (8) !         call get_cgps_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !      case (9) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !      case (10) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !      case (11) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !      case (12) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_gf(ll_in, ll_out) !      case (13) !         call get_strong_motion_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !         lL_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !      case (14) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !      case (15) !         call get_body_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_strong_motion_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_surface_waves_gf(ll_in, ll_out) !         ll_in = ll_out !         call get_cgps_gf(ll_in, ll_out) !   endselect end subroutine get_gf subroutine get_strong_motion_gf ( ll_in , ll_out ) implicit none integer ll_in , ll_out , io_v_d , ll_g , ll , & & nstb , io_chan , i , i_s , ir , no , & & n_wave_weight , ir_max , n_chan , & & nos ( nnsta ), io_mod ( nnsta ), ixs , iys , n_chan3 , lnpt , nlen , & & jmin , jmax , jfmax real omega , block , lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , depth , & & weig , df , dt_sample , w , tlen complex z0 , z character ( len = 80 ) path character ( len = 6 ) sta_name ( nnsta ) character ( len = 80 ) filename character ( len = 3 ) component ( nnsta ), comp z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! block = dxs * dys * ( 1.e-10 ) write ( * , * ) 'block: ' , block write ( * , * ) 'area=' , dxs * dys open ( 9 , file = 'Readlp.inf' , status = 'old' ) open ( 13 , file = 'Obser.str' , status = 'unknown' ) open ( 15 , file = 'Wave.str' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , '(a)' ) path read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) lnpt , dt_sample read ( 9 , * ) io_v_d nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations betweeen wavelet file and stations file' stop end if ir = 0 io_chan = 0 ! !       Here we read the green functions of strong motion waves ! df = 1. / (( 2.0 ** lnpt ) * dt ) nlen = 2 ** lnpt tlen = nlen * dt do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), component ( ir ), weig , nos ( ir ) comp = component ( ir ) io_chan = io_chan + 1 ll_g = io_chan + ll_in if ( comp . eq . 'HNZ' ) filename = trim ( sta_name ( ir )) // '1' if ( comp . eq . 'HNN' ) filename = trim ( sta_name ( ir )) // '2' if ( comp . eq . 'HNE' ) filename = trim ( sta_name ( ir )) // '3' filename = trim ( filename ) open ( 12 , file = filename , status = 'unknown' , access = 'direct' , recl = block_stg ) ll = 0 ! !       Here, we read the green functions and derivate them ! ll_g = ll_in + io_chan do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 read ( 12 , rec = ll )( green_dip ( i , ll_g , ll ), i = 1 , jfmax ),( green_stk ( i , ll_g , ll ), i = 1 , jfmax ) do i = 1 , jfmax ! ! we eventually shift synthetics in time, in case the fault plane used has a delay ! omega = twopi * ( i - 1 ) * df w = - omega * delay_seg ( i_s ) z = cmplx ( 0.0 , w ) z = cexp ( z ) green_dip ( i , ll_g , ll ) = green_dip ( i , ll_g , ll ) * z * block green_stk ( i , ll_g , ll ) = green_stk ( i , ll_g , ll ) * z * block end do end do end do end do close ( 12 ) end do close ( 15 ) close ( 9 ) close ( 7 ) close ( 12 ) close ( 13 ) ll_out = ll_out + n_chan end subroutine get_strong_motion_gf subroutine get_cgps_gf ( ll_in , ll_out ) implicit none integer ll_in , ll_out , ll_g , ll , n_chan3 , & & nstb , io_chan , i , i_s , ir , no , lnpt , nlen , & & n_wave_weight , ir_max , n_chan , nos ( nnsta ), io_mod ( nnsta ), ixs , iys , & & jmin , jmax , jfmax real omega , block , lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , depth , & & weig , df , dt_sample , w , low_freq , tlen complex z0 , z character ( len = 80 ) path character ( len = 6 ) sta_name ( nnsta ) character ( len = 80 ) filename character ( len = 3 ) component ( nnsta ), comp z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gfs is for Mo = 1e+20 ! block = dxs * dys * ( 1.e-10 ) write ( * , * ) 'block: ' , block write ( * , * ) 'area=' , dxs * dys open ( 9 , file = 'Readlp.cgps' , status = 'old' ) open ( 13 , file = 'Obser.cgps' , status = 'unknown' ) open ( 15 , file = 'Wave.cgps' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , '(a)' ) path read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) lnpt , dt_sample read ( 9 , * ) nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in number of stations between wavelet file and stations file' stop end if ir = 0 io_chan = 0 ! !       Here we read the green functions of strong motion waves ! df = 1. / (( 2.0 ** lnpt ) * dt ) nlen = 2 ** lnpt tlen = nlen * dt low_freq = 1.0 / 20 0.0 do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), component ( ir ), weig , nos ( ir ) comp = component ( ir ) io_chan = io_chan + 1 ll_g = io_chan + ll_in if ( comp . eq . 'LXZ' ) filename = trim ( sta_name ( ir )) // '.cgps.1' if ( comp . eq . 'LXN' ) filename = trim ( sta_name ( ir )) // '.cgps.2' if ( comp . eq . 'LXE' ) filename = trim ( sta_name ( ir )) // '.cgps.3' filename = trim ( filename ) open ( 12 , file = filename , status = 'unknown' , access = 'direct' , recl = block_stg ) ll = 0 ! !       Here, we read the green functions and derivate them ! ll_g = ll_in + io_chan do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 read ( 12 , rec = ll )( green_dip ( i , ll_g , ll ), i = 1 , jfmax ),( green_stk ( i , ll_g , ll ), i = 1 , jfmax ) do i = 1 , jfmax omega = twopi * ( i - 1 ) * df w = - omega * delay_seg ( i_s ) ! we shift synthetics in time by delay_seg(i_s) seconds z = cmplx ( 0.0 , w ) z = cexp ( z ) green_dip ( i , ll_g , ll ) = green_dip ( i , ll_g , ll ) * z * block green_stk ( i , ll_g , ll ) = green_stk ( i , ll_g , ll ) * z * block end do end do end do end do close ( 12 ) end do close ( 15 ) close ( 9 ) close ( 7 ) close ( 12 ) close ( 13 ) ll_out = ll_out + n_chan end subroutine get_cgps_gf subroutine get_body_waves_gf ( ll_in , ll_out ) implicit none integer nstaon , ir , ll_g , k , nsta , n_chan , & & love , ll , i_s , iys , iyp , io_seg , iys_c , iy_c , jf , i , nstb , ipy , npxy , & & nkxy , nxs_c , nys_c , nxp_c , nyp_c , ll_s , kxy , ixs , kpxy , ixp , & & n_wave_weight , iud ( nnsta_tele ), & & idata ( nnsta_tele ), nos ( nnsta_tele ), llove ( nnsta_tele ), & & mmm ( nnsta_tele ), ll_in , ll_out , n_chan3 , lnpt , & & nlen , jmin , jmax , jfmax real dt , df , ddelt , time , block , w , & & earth_angle ( nnsta_tele ), hcru ( nnsta_tele ), & & disp_or_vel ( nnsta_tele ), rang ( nnsta_tele ), az ( nnsta_tele ), & & ttvl ( nnsta_tele ), & & lat_sta ( nnsta_tele ), lon_sta ( nnsta_tele ), tlen real , allocatable :: tdel (:,:,:,:) complex :: z , z0 , wsyn ( npth ) complex :: kahan_y1 ( inptd ), kahan_t1 ( inptd ), kahan_c1 ( inptd ) complex :: kahan_y2 ( inptd ), kahan_t2 ( inptd ), kahan_c2 ( inptd ) complex , allocatable :: green_dip0 (:,:,:,:,:) complex , allocatable :: green_stk0 (:,:,:,:,:) ! character ( len = 5 ) earth ( nnsta_tele ) character ( len = 14 ) fname ( nnsta_tele ) character ( len = 6 ) stname ( nnsta_tele ), sttyp ( nnsta_tele ) character ( len = 14 ) fname4 , fname6 allocate ( green_dip0 ( npuse , nnpy , nnys , max_seg , nnsta_tele )) allocate ( green_stk0 ( npuse , nnpy , nnys , max_seg , nnsta_tele )) allocate ( tdel ( nnpxy , nnxy , max_seg , nnsta_tele )) z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 open ( 9 , file = 'Readlp.das' , status = 'old' ) open ( 13 , file = 'Obser.tele' , status = 'unknown' ) if ( jfmax . gt . npuse ) then write ( * , * ) 'You should stop and check dimension sww,sws' stop end if read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) read ( 9 , * ) nstaON nstb = 0 block = dxs * dys * ( 1.0e-10 ) block = block * 1.e+4 ! !  Because the data is micrometer, so The amplitude of block should !  time e+4 Only in this test ! open ( 15 , file = 'Wave.tele' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , * ) n_wave_weight tlen = nlen * dt npxy = nx_p * ny_p do ir = 1 , nstaon ll_g = ll_in + ir read ( 9 , * ) nos ( ir ), earth ( ir ), sttyp ( ir ), stname ( ir ), fname ( ir ), & & rang ( ir ), az ( ir ), lat_sta ( ir ), lon_sta ( ir ), earth_angle ( ir ), ttvl ( ir ), & & mmm ( ir ), hcru ( ir ), disp_or_vel ( ir ), llove ( ir ), iud ( ir ), idata ( ir ) if ( idata ( ir ) . gt . 0 . or . mmm ( ir ) . eq . 3 ) cycle nstb = nstb + 1 nsta = nstaON n_chan = nstaon love = llove ( ir ) ! !  MM = 0 FOR FAR; MM = 1 FOR UPPER; MM = 3 FOR PNL !  Here we read the green functions of the teleseismic body waves ! if ( love . eq . 0 ) then fname4 = trim ( stname ( ir )) // '.GRE' fname6 = trim ( stname ( ir )) // '.TDE' else fname4 = trim ( stname ( ir )) // 'SH.GRE' fname6 = trim ( stname ( ir )) // 'SH.TDE' end if open ( 12 , file = fname4 , status = 'unknown' , access = 'direct' , recl = block_far ) open ( 32 , file = fname6 , status = 'unknown' , access = 'direct' , recl = ltde ) LL = 0 do i_s = 1 , n_seg if ( i_s . le . 10 ) then do iys = 1 , nys_sub ( i_s ) do IPY = 1 , ny_p LL = LL + 1 read ( 12 , rec = LL ) io_seg , iys_c , iy_c , JF , DT , DF , & & ( green_dip0 ( i , ipy , iys , i_s , ir ), i = 1 , 2 * jfmax ) LL = LL + 1 read ( 12 , rec = LL ) io_seg , iys_c , iy_c , JF , LNPT , NLEN , & & ( green_stk0 ( i , ipy , iys , i_s , ir ), I = 1 , 2 * JFmax ) ! !       Sanity checks ! if (( io_seg . ne . i_s ) . or . ( iys_c . ne . iys ) . or . ( iy_c . ne . ipy )) then write ( * , * ) 'io_seg vs i_s: ' , io_seg , i_s write ( * , * ) 'iys_c, iys: ' , iys_c , iys write ( * , * ) 'iy_c, ipy: ' , iy_c , ipy write ( * , * ) \"Green function is not matched with fault model\" stop end if do i = 1 , 2 * jfmax green_dip0 ( i , ipy , iys , i_s , ir ) = block * green_dip0 ( i , ipy , iys , i_s , ir ) green_stk0 ( i , ipy , iys , i_s , ir ) = block * green_stk0 ( i , ipy , iys , i_s , ir ) end do end do end do nkxy = nxs_sub ( i_s ) * nys_sub ( i_s ) read ( 32 , rec = i_s ) nxs_c , nys_c , nxp_c , nyp_c , & & (( tdel ( k , ll_s , i_s , ir ), k = 1 , npxy ), ll_s = 1 , nkxy ) if (( nxs_c . ne . nxs_sub ( i_s )) . or . ( nys_c . ne . nys_sub ( i_s )) & & . or .( nxp_c . ne . nx_p ) . or . ( nyp_c . ne . ny_p )) then write ( * , * ) 'nxs' , nxs_c , nxs_sub ( i_s ) write ( * , * ) 'nys' , nys_c , nys_sub ( i_s ) write ( * , * ) 'nxp' , nxp_c , nx_p write ( * , * ) 'nyp' , nyp_c , ny_p write ( * , '(a)' ) 'Mismatch in amount of point sources or subfaults & &between the specified in Fault.time, and those used in the & &green functions.' stop end if else npxy = nx_p * ny_p nkxy = nxs_sub ( i_s ) * nys_sub ( i_s ) do iys = 1 , nys_sub ( i_s ) do ipy = 1 , ny_p do i = 1 , 2 * jfmax green_dip0 ( i , ipy , iys , i_s , ir ) = z0 green_stk0 ( i , ipy , iys , i_s , ir ) = z0 end do end do end do do ll_s = 1 , nkxy do k = 1 , npxy tdel ( k , ll_s , i_s , ir ) = 0.0 end do end do end if end do close ( 12 ) close ( 32 ) end do close ( 9 ) close ( 13 ) close ( 15 ) do ir = 1 , nstaon ll_g = ll_in + ir do I = 1 , npth wsyn ( i ) = z0 end do LL = 0 ddelt = 0.0 z = z0 do i_s = 1 , n_seg kxy = 0 do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) kxy = kxy + 1 ll = ll + 1 do i = 1 , 2 * jfmax green_dip ( i , ll_g , ll ) = z0 green_stk ( i , ll_g , ll ) = z0 end do kahan_y1 (:) = z0 kahan_t1 (:) = z0 kahan_c1 (:) = z0 kahan_y2 (:) = z0 kahan_t2 (:) = z0 kahan_c2 (:) = z0 kpxy = 0 do iyp = 1 , ny_p do ixp = 1 , nx_p kpxy = kpxy + 1 time = tdel ( kpxy , kxy , i_s , ir ) + & & point_sources ( 4 , ixp , iyp , ixs , iys , i_s ) / v_ref + delay_seg ( i_s ) do i = 1 , 2 * jfmax W = - twopi * ( i - 1 ) * df * time z = cmplx ( 0.0 , w ) z = cexp ( z ) !                        green_dip(i, ll_g, ll) = green_dip(i, ll_g, ll)+green_dip0(i, iyp, iys, i_s, ir)*Z !                        green_stk(i, ll_g, ll) = green_stk(i, ll_g, ll)+green_stk0(i, iyp, iys, i_s, ir)*z kahan_y1 ( i ) = green_dip0 ( i , iyp , iys , i_s , ir ) * z - kahan_c1 ( i ) kahan_t1 ( i ) = green_dip ( i , ll_g , ll ) + kahan_y1 ( i ) kahan_c1 ( i ) = ( kahan_t1 ( i ) - green_dip ( i , ll_g , ll )) - kahan_y1 ( i ) green_dip ( i , ll_g , ll ) = kahan_t1 ( i ) kahan_y2 ( i ) = green_stk0 ( i , iyp , iys , i_s , ir ) * z - kahan_c2 ( i ) kahan_t2 ( i ) = green_stk ( i , ll_g , ll ) + kahan_y2 ( i ) kahan_c2 ( i ) = ( kahan_t2 ( i ) - green_stk ( i , ll_g , ll )) - kahan_y2 ( i ) green_stk ( i , ll_g , ll ) = kahan_t2 ( i ) end do end do end do do i = 1 , 2 * jfmax if ( int ( disp_or_vel ( ir ) + 0.1 ) . eq . 0 ) then z = cmplx ( 1.0 , 0.0 ) elseif ( int ( disp_or_vel ( ir ) + 0.1 ) . eq . 1 ) then w = twopi * ( i - 1 ) * df z = cmplx ( 0.0 , w ) end if green_dip ( i , ll_g , ll ) = z * green_dip ( i , ll_g , ll ) / npxy green_stk ( i , ll_g , ll ) = z * green_stk ( i , ll_g , ll ) / npxy end do end do end do end do end do ll_out = ll_out + nstaon deallocate ( green_stk0 ) deallocate ( green_dip0 ) deallocate ( tdel ) end subroutine get_body_waves_gf subroutine get_surface_waves_gf ( ll_in , ll_out ) implicit none integer ll_in , ll_out , nf1 , nf2 , nf3 , nf4 , no , & & npp , ix , iy , nxy , j , ll_g , ll , nstb , io_chan , i , k , io_mod ( nnsta ), & & i_s , ir , i_ch , n_wave_weight , ir_max , n_chan , & & iys , ixs , io_up ( nnsta ), io_ew ( nnsta ), io_ns ( nnsta ), & & n_chan3 , jmin , jmax , jfmax , lnpt , nlen real * 8 :: dip , theta , dis , az , baz , rad_c , coef_v ( 2 , 3 ), coef_r ( 2 , 5 ) real fint ( npth ), f1 , f2 , f3 , f4 , const_c , tsub ( nnpxy ), h , omega , & & dist_min , dist_max , depth_sub , dep_min , dep_max , lat_p , lon_p , niu , & & lat_sta , lon_sta , df_bank , tlen_bank , & & time , a , block , lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , rake , & & depth , ang_ns ( nnsta ), ang_ew ( nnsta ), df , area , dt_sample , tlen complex :: kahan_y , kahan_t , kahan_c complex sour_sub ( npth ), green_s ( inptd , 10 ), www , wss , z0 character ( len = 250 ) modes character ( len = 100 ) surf_gf_bank character ( len = 6 ) sta_name ( nnsta ) z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 ! !  suppose the ni = u3e+11, then then moment of 1cm*1km&#94;2 !       subfault is 3e+21. The gf is for Mo = 1e+20 dyne.cm !  the unit of surface wave is mm. ! area = dxs * dys block = 100 0.0 * area * ( 1.e-10 ) open ( 9 , file = 'Readlp.inf_low' , status = 'old' ) open ( 13 , file = 'Obser.str_low' , status = 'unknown' ) open ( 15 , file = 'Wave.str_low' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , '(a)' ) modes read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) dip , rake , theta , lnpt , dt_sample read ( 9 , * ) if ( lnpt . ne . 10 ) then write ( * , * ) \"please check input LNPT\" end if nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations between wavelet file and stations file' stop end if do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), & & io_up ( ir ), io_ns ( ir ), io_ew ( ir ), ang_ns ( ir ), ang_ew ( ir ) end do !  int !  by default frequency window: 0.003 0.004 0.007 0.008 ! f1 = 0.003 f2 = 0.004 f3 = 0.006 f4 = 0.007 nf1 = int ( f1 / df ) nf2 = int ( f2 / df ) nf3 = int ( f3 / df ) nf4 = int ( f4 / df ) + 1 do k = 1 , nlen / 2 fint ( k ) = 1.0 if ( k . ge . nf4 . or . k . lt . nf1 ) fint ( k ) = 0.0 if ( k . ge . nf1 . and . k . lt . nf2 . and . (( nf2 - nf1 ) . gt . 0 )) then fint ( k ) = 0.5 * ( 1.0 - cos ( pi * ( k - nf1 ) / ( nf2 - nf1 ))) end if if ( k . gt . nf3 . and . k . lt . nf4 . and . (( nf4 - nf3 ) . gt . 0 )) then fint ( k ) = 0.5 * ( 1.0 + cos ( pi * ( k - nf3 ) / ( nf4 - nf3 ))) end if fint ( k ) = fint ( k ) * block end do io_chan = 0 npp = nx_p * ny_p ! !       Here we read the green functions of long period surface waves ! call get_surf_gf_data ( modes , surf_gf_bank ) tlen_bank = npt_bank * dt_bank df_bank = 1.0 / tlen_bank const_c = dt_bank / dt ll = 0 dist_min = 2 0.0 dist_max = 12 0.0 do i_s = 1 , n_seg dip = dip_seg ( i_s ) theta = stk_seg ( i_s ) do iys = 1 , nys_sub ( i_s ) nxy = ( iys - 1 ) * nxs_sub ( i_s ) + 1 depth_sub = point_sources ( 3 , 1 , int ( ny_p / 2 ) + 1 , 1 , iys , i_s ) dep_min = point_sources ( 3 , 1 , 1 , 1 , iys , i_s ) - 1.0 dep_max = point_sources ( 3 , 1 , ny_p , 1 , iys , i_s ) + 1.0 if ( dep_min . lt . 4 ) dep_min = 4 ! !  Sanity check: ! if ( dep_max . lt . dep_min ) dep_max = 4 ! call get_surf_gf ( surf_gf_bank , dist_min , dist_max , dep_min , dep_max ) ! !       Note that if the tlen is same in both gf bank and used in here !       values at each frequency are same. In this code, we will let dt_bank = 2 sec !       and npt_bank = 2048, in contrast, dt_sample = 4 sec, npt_bank = 1024 ! do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 nxy = ( iys - 1 ) * nxs_sub ( i_s ) + ixs lat_p = point_sources ( 1 , int ( nx_p / 2 ) + 1 , int ( ny_p / 2 ) + 1 , ixs , iys , i_s ) lon_p = point_sources ( 2 , int ( nx_p / 2 ) + 1 , int ( ny_p / 2 ) + 1 , ixs , iys , i_s ) niu = cniu ( nxy , i_s ) do i = 1 , jfmax omega = ( i - 1 ) * df_bank * twopi sour_sub ( i ) = cmplx ( 0.0 , 0.0 ) kahan_y = z0 kahan_t = z0 kahan_c = z0 do iy = 1 , ny_p do ix = 1 , nx_p h = point_sources ( 4 , ix , iy , ixs , iys , i_s ) time = h / v_ref tsub ( 1 ) = time + delay_seg ( i_s ) a = - omega * tsub ( 1 ) kahan_y = cmplx ( cos ( a ), sin ( a )) - kahan_c kahan_t = sour_sub ( i ) + kahan_y kahan_c = ( kahan_t - sour_sub ( i )) - kahan_y sour_sub ( i ) = kahan_t !                     sour_sub(i) = sour_sub(i)+cmplx(cos(a), sin(a)) end do end do sour_sub ( i ) = sour_sub ( i ) * const_c / npp end do io_chan = 0 do ir = 1 , ir_max lat_sta = lat_s ( ir ) lon_sta = lon_s ( ir ) call distaz ( lat_sta , lon_sta , lat_p , lon_p , dis , az , baz ) dis = dis / 11 1.32d0 green_s = interp_gf ( dis , depth_sub , dist_min , dist_max , dep_min , dep_max ) do i_ch = 1 , 3 if ( i_ch . eq . 1. and . io_up ( ir ). ne . 1 ) then cycle elseif ( i_ch . eq . 1 . and . io_up ( ir ) . eq . 1 ) then rad_c = 0.0 end if if ( i_ch . eq . 2. and . io_ns ( ir ). ne . 1 ) then cycle elseif ( i_ch . eq . 2 . and . io_ns ( ir ) . eq . 1 ) then rad_c = ang_ns ( ir ) end if if ( i_ch . eq . 3. and . io_ew ( ir ). ne . 1 ) then cycle elseif ( i_ch . eq . 3 . and . io_ew ( ir ) . eq . 1 ) then rad_c = ang_ew ( ir ) end if io_chan = io_chan + 1 ll_g = io_chan + ll_in call rad_coef ( dip , theta , az , rad_c , coef_v , coef_r ) do i = 1 , jfmax www = cmplx ( 0.0 , 0.0 ) wss = cmplx ( 0.0 , 0.0 ) if ( i_ch . eq . 1 ) then do j = 1 , 3 www = www + coef_v ( 1 , j ) * green_s ( i , j + 5 ) wss = wss + coef_v ( 2 , j ) * green_s ( i , j + 5 ) end do else do j = 1 , 5 www = www + coef_r ( 1 , j ) * green_s ( i , j ) wss = wss + coef_r ( 2 , j ) * green_s ( i , j ) end do end if if ( i . le . jfmax . and . i_s . le . 10 ) then green_stk ( i , ll_g , ll ) = wss * fint ( i ) * sour_sub ( i ) * niu green_dip ( i , ll_g , ll ) = www * fint ( i ) * sour_sub ( i ) * niu else green_dip ( i , ll_g , ll ) = cmplx ( 0.0 , 0.0 ) green_stk ( i , ll_g , ll ) = cmplx ( 0.0 , 0.0 ) end if end do end do end do end do end do end do close ( 15 ) close ( 9 ) close ( 13 ) ll_out = ll_out + n_chan return end subroutine get_surface_waves_gf subroutine get_dart_gf ( ll_in , ll_out ) implicit none integer ll_in , ll_out , io_v_d , ll_g , ll , & & nstb , io_chan , i , i_s , ir , no , ix , iy , npp , & & n_wave_weight , ir_max , n_chan , & & nos ( nnsta ), io_mod ( nnsta ), ixs , iys , n_chan3 , lnpt , nlen , & & jmin , jmax , jfmax real omega , block , lat_e , lon_e , lat_s ( nnsta ), lon_s ( nnsta ), dt , depth , & & weig , df , dt_sample , w , tlen , gf_real ( inptd ), gf_real2 ( inptd , nnxy_m ), & & gf_imag ( inptd ), h , time , tsub ( nnxy_m ), a complex z0 , z , sour_sub ( npth ) complex :: kahan_y , kahan_t , kahan_c character ( len = 80 ) path character ( len = 6 ) sta_name ( nnsta ) character ( len = 80 ) filename z0 = cmplx ( 0.0 , 0.0 ) n_chan3 = 0 npp = nx_p * ny_p ! block = ( 1.e-2 ) write ( * , * ) 'block: ' , block write ( * , * ) 'area=' , dxs * dys open ( 9 , file = 'Readlp.dart' , status = 'old' ) open ( 13 , file = 'Obser.dart' , status = 'unknown' ) open ( 15 , file = 'Wave.dart' ) read ( 15 , * ) jmin , jmax , jfmax read ( 15 , '(a)' ) path read ( 15 , * ) n_wave_weight read ( 9 , * ) read ( 9 , * ) lat_e , lon_e , depth read ( 9 , * ) lnpt , dt_sample read ( 9 , * ) io_v_d nstb = 0 nlen = 2 ** lnpt dt = dt_sample tlen = dt * nlen df = 1.0 / tlen read ( 9 , * ) ir_max , n_chan read ( 9 , * ) if ( n_wave_weight . ne . n_chan ) then write ( * , * ) 'n_wave_chan n_chan' , n_wave_weight , n_chan write ( * , * ) 'Mismatch in amount of stations betweeen wavelet file and stations file' stop end if ir = 0 io_chan = 0 ! !       Here we read the green functions of strong motion waves ! df = 1. / (( 2.0 ** lnpt ) * dt ) nlen = 2 ** lnpt tlen = nlen * dt gf_real2 (:, :) = 0.0 do ir = 1 , ir_max read ( 9 , * ) no , sta_name ( ir ), lat_s ( ir ), lon_s ( ir ), io_mod ( ir ), weig , nos ( ir ) io_chan = io_chan + 1 ll_g = io_chan + ll_in filename = trim ( sta_name ( ir )) // '_gf.txt' filename = trim ( filename ) open ( 12 , file = filename ) do i = 1 , 181 read ( 12 , * )( gf_real2 ( i + 10 , ll ), ll = 1 , nxs_sub ( 1 ) * nys_sub ( 1 )) enddo close ( 12 ) ll = 0 ix = int ( nx_p / 2.0 + 0.51 ) iy = int ( ny_p / 2.0 + 0.51 ) ! !       Here, we read the green functions ! ll_g = ll_in + io_chan do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ! !  effect of point sources of each subfault ! do i = 1 , jfmax omega = ( i - 1 ) * df * twopi time = point_sources ( 5 , ix , iy , ixs , iys , i_s ) tsub ( 1 ) = time + delay_seg ( i_s ) a = - omega * tsub ( 1 ) !                  sour_sub(i) = cmplx(0.0, 0.0) sour_sub ( i ) = cmplx ( cos ( a ), sin ( a )) !                  kahan_y = z0 !                  kahan_t = z0 !                  kahan_c = z0 !                  do iy = 1, ny_p !                     do ix = 1, nx_p !                        h = point_sources(4, ix, iy, ixs, iys, i_s) !                        time = h/v_ref !                        tsub(1) = time+delay_seg(i_s) !                        a = -omega*tsub(1) !                        kahan_y = cmplx(cos(a), sin(a)) - kahan_c !                        kahan_t = sour_sub(i) + kahan_y !                        kahan_c = (kahan_t - sour_sub(i)) - kahan_y !                        sour_sub(i) = kahan_t !!                        sour_sub(i) = sour_sub(i)+cmplx(cos(a), sin(a)) !                     end do !                  end do !                  sour_sub(i) = sour_sub(i) / npp end do gf_real (:) = 0.0 gf_imag (:) = 0.0 ll = ll + 1 green_stk (:, ll_g , ll ) = 0.0 gf_real (:) = gf_real2 (:, ll ) call fft ( gf_real , gf_imag , lnpt , - 1.0 ) do i = 1 , jfmax green_dip ( i , ll_g , ll ) = cmplx ( gf_real ( i ), gf_imag ( i )) ! ! we eventually shift synthetics in time, in case the fault plane used has a delay ! omega = twopi * ( i - 1 ) * df w = - omega * ( delay_seg ( i_s ) - 1 0.0 * dt ) !9.0*dt - 13) z = cmplx ( cos ( w ), sin ( w )) green_dip ( i , ll_g , ll ) = green_dip ( i , ll_g , ll ) * z * block * sour_sub ( i ) end do end do end do end do end do close ( 15 ) close ( 9 ) close ( 7 ) close ( 13 ) ll_out = ll_out + n_chan end subroutine get_dart_gf subroutine deallocate_gf () deallocate ( green_stk ) deallocate ( green_dip ) end subroutine deallocate_gf end module retrieve_gf","title":"retrieve_gf.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/run_forward.f95.html","text":"Contents Programs run_forward Source Code run_forward.f95 Source Code program run_forward use constants , only : max_seg , nt1 , nnxy use model_parameters , only : get_faults_data , slip0 , rake0 , rupt_time0 , tl0 , tr0 , write_model use modelling_inputs , only : get_annealing_param use get_stations_data , only : get_data use retrieve_gf , only : get_gf use save_forward , only : write_forward use static_data , only : initial_gps implicit none integer i character ( len = 10 ) :: input logical :: static , strong , cgps , body , surf , dart static = . False . strong = . False . cgps = . False . body = . False . surf = . False . dart = . False . do i = 1 , iargc () call getarg ( i , input ) input = trim ( input ) if ( input . eq . 'gps' ) static = . True . if ( input . eq . 'strong' ) strong = . True . if ( input . eq . 'cgps' ) cgps = . True . if ( input . eq . 'body' ) body = . True . if ( input . eq . 'surf' ) surf = . True . if ( input . eq . 'dart' ) dart = . True . end do call get_annealing_param () call get_faults_data () call get_gf ( strong , cgps , body , surf , dart ) call get_data ( strong , cgps , body , surf , dart ) call write_forward ( slip0 , rake0 , rupt_time0 , tl0 , tr0 , strong , cgps , body , surf , dart ) if ( static ) call initial_gps ( slip0 , rake0 ) call write_model ( slip0 , rake0 , rupt_time0 , tl0 , tr0 ) end program run_forward","title":"run_forward.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/annealing.f95.html","text":"Contents Modules annealing Source Code annealing.f95 Source Code module annealing use constants , only : pi , nnsta , dpi , twopi , nnxy , max_seg , inptd , nt1 , npth , nnxy_m use retrieve_gf , only : green_dip , green_stk use wavelets , only : wavelet_syn use wavelet_param , only : jfmax , lnpt use rise_time , only : source use get_stations_data , only : dt_channel use random_gen , only : ran1 , cauchy use misfit_eval , only : misfit use modelling_inputs , only : smooth_moment , smooth_slip , smooth_time , io_re , cm_point use model_parameters , only : n_seg , ta0 , dta , msou , dxs , dys , nxs0 , nys0 , nx_p , ny_p , v_min , v_max , & & tbl , tbr , v_ref , nxs_sub , nys_sub , time_max , time_min , cniu , & & slip0 , rake0 , rupt_time0 , tl0 , tr0 , c_depth , beg , dp , np , dip_seg , & & stk_seg , delay_seg use regularization , only : lap , tlap , define_slip_field , modify_slip_field use static_data , only : static_synthetic , static_remove_subfault , & & static_modify_subfault , static_add_subfault implicit none real :: coef_moment , coef_slip , coef_st , coef_time real :: emin , ermin , min_dt , area integer :: n_chan , nxys ( max_seg ), nnn integer , parameter :: double = kind ( 1.d0 ) integer , private :: threads integer , parameter , private :: max_move = 50 , accept_max = 5 contains subroutine n_threads ( auto ) use omp_lib implicit none logical :: auto threads = 4 if ( auto ) threads = 3 call omp_set_num_threads ( threads ) end subroutine n_threads subroutine initial_model ( slip , rake , rupt_time , tl , tr ) !! !!  We define initial model for the annealing method. !! implicit none real :: slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tl ( nnxy , max_seg ), tr ( nnxy , max_seg ) real :: x ( nt1 ) integer :: nxy , i , i_g , i_seg , io_v_d , k , kp , npa io_v_d = 0 npa = 0 do i_seg = 1 , n_seg npa = npa + 4 * nxs_sub ( i_seg ) * nys_sub ( i_seg ) end do do k = 1 , npa x ( k ) = beg ( k ) + int ( ran1 () * np ( k ) - 1.0 ) * dp ( k ) end do if ( io_re . eq . 0 ) then k = 0 do i_seg = 1 , n_seg nxy = nxs_sub ( i_seg ) * nys_sub ( i_seg ) do i = 1 , nxy k = k + 1 slip ( i , i_seg ) = x ( k ) k = k + 1 rake ( i , i_seg ) = x ( k ) k = k + 2 tl ( i , i_seg ) = ( ta0 + int ( ran1 () * msou ) * dta ) tr ( i , i_seg ) = ( ta0 + int ( ran1 () * msou ) * dta ) rupt_time ( i , i_seg ) = ran1 () * & & ( time_max ( i , i_seg ) - time_min ( i , i_seg )) + time_min ( i , i_seg ) end do end do open ( 12 , file = 'Fault.ini' ) write ( 12 , * ) nxs0 , nys0 , c_depth write ( 12 , * ) n_seg , dxs , dys , nx_p , ny_p , v_min , v_max , tbl , tbr write ( 12 , * ) ta0 , dta , msou , v_ref , io_v_d do i_g = 1 , n_seg nxys ( i_g ) = nxs_sub ( i_g ) * nys_sub ( i_g ) write ( 12 , * ) i_g , dip_seg ( i_g ), stk_seg ( i_g ) write ( 12 , * ) nxs_sub ( i_g ), nys_sub ( i_g ), delay_seg ( i_g ) do kp = 1 , nxys ( i_g ) write ( 12 , * ) slip ( kp , i_g ), rake ( kp , i_g ), rupt_time ( kp , i_g ), tl ( kp , i_g ), tr ( kp , i_g ) end do end do close ( 12 ) else slip (:, :) = slip0 (:, :) rake (:, :) = rake0 (:, :) rupt_time (:, :) = rupt_time0 (:, :) tl (:, :) = tl0 (:, :) tr (:, :) = tr0 (:, :) end if end subroutine initial_model subroutine initial_regularization ( slip , rake , rupt_time , tl , tr , static ) !! !!  We compute regularization coefficients, and store them in memory. !! implicit none real :: slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ) real :: tl ( nnxy , max_seg ), tr ( nnxy , max_seg ) real amp , cmoment , derr , dt , er , er0 , err_s , err_static , & & err_time , forward_real ( inptd , nnsta ), a , b , & & forward_imag ( inptd , nnsta ), cr ( inptd ), cz ( inptd ), forward2 ( inptd ) real :: ex , rake2 , df , df_ref , dsum , kahan_y , kahan_t , kahan_c real * 8 :: omega , ersum2 integer :: i , i_s , ir , isl , isr , ixs , iys , jf , k , ll , ll_s complex * 16 :: z0 , forward ( npth ), z , z1 logical :: static z0 = cmplx ( 0.d0 , 0.d0 , double ) min_dt = 10 do i = 1 , nnsta if ( dt_channel ( i ) . gt . 1.e-4 ) min_dt = min ( min_dt , dt_channel ( i )) end do n_chan = 0 do i = 1 , nnsta if ( dt_channel ( i ) . gt . 1.e-4 ) n_chan = n_chan + 1 end do jf = 2 ** ( lnpt - 1 ) + 1 ! ! Compute synthetics given current fault model ! area = dxs * dys * ( 1.e+10 ) df_ref = 1.0 / ( 2.0 ** lnpt ) ersum2 = 0.0 do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) dt = dt_channel ( ir ) do i = 1 , npth forward ( i ) = z0 end do ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * source ( i , ir , isl , isr ) * z z = z * z1 end do end do end do end do do i = 1 , npth forward_real ( i , ir ) = real ( forward ( i )) forward_imag ( i , ir ) = aimag ( forward ( i )) cr ( i ) = forward_real ( i , ir ) cz ( i ) = forward_imag ( i , ir ) end do call wavelet_syn ( cr , cz , forward2 ) call misfit ( ir , forward2 , ex ) ersum2 = ersum2 + ex end do amp = 1.0 dsum = 0.0 kahan_y = 0.0 kahan_t = 0.0 kahan_c = 0.0 do i_s = 1 , n_seg do k = 1 , nxys ( i_s ) kahan_y = slip ( k , i_s ) * cniu ( k , i_s ) - kahan_c kahan_t = dsum + kahan_y kahan_c = ( kahan_t - dsum ) - kahan_y dsum = kahan_t !         dsum = dsum+slip(k, i_s)*cniu(k, i_s)    ! we may need to increase numerical precision end do end do cmoment = dsum * area derr = ( cmoment / cm_point ) er0 = ersum2 coef_moment = smooth_moment coef_moment = min ( coef_moment , 1.0 ) call define_slip_field ( slip , rake ) call lap ( err_s ) coef_slip = smooth_slip * er0 / ( err_s * amp ) call tlap ( rupt_time , err_time ) if ( err_time . lt . 1.0e-9 ) err_time = 1.0 coef_time = smooth_time * er0 / ( err_time * amp ) coef_st = 0.0 if ( static ) then call static_synthetic ( slip , rake , nxys , err_static ) coef_st = er0 / ( err_static * amp ) end if coef_slip = min ( 0.003 , coef_slip ) er = ersum2 + coef_moment * derr + coef_slip * err_s * amp er = er + coef_time * err_time + coef_st * err_static nnn = 0 do i_s = 1 , n_seg nxys ( i_s ) = nys_sub ( i_s ) * nxs_sub ( i_s ) nnn = nnn + nxys ( i_s ) end do write ( * , * ) '' write ( * , * ) 'averaged misfit error' , er0 write ( * , * ) 'moment error' , derr write ( * , * ) 'slip smoothness penalization' , err_s write ( * , * ) 'time smoothness penalization' , err_time if ( static ) write ( * , * ) 'static data penalization' , err_static write ( * , * ) 'total moment of the inversion' , cmoment write ( * , * ) '' write ( * , * ) 'moment error coefficient' , coef_moment write ( * , * ) 'slip smoothness penalization coefficient' , coef_slip write ( * , * ) 'time smoothness penalization coefficient' , coef_time if ( static ) write ( * , * ) 'static data penalization coefficient' , coef_st write ( * , * ) '' write ( * , * ) 'Amount of variables: ' , 5 * nnn write ( * , * ) 'Amount of data values: ' , n_chan * jfmax emin = er ermin = er end subroutine initial_regularization subroutine annealing_iter ( slip , rake , rupt_time , tl , tr , er , t ) !! !!  We compute an iteration of the annealing method. !!  Non-parallelized version. !! implicit none integer isl , isr , nn_sub , nsub ( nnxy_m ), n_accept , & & nbb , i , k , npb , nn , nran , ll_s , i_s , i_ss , ir , ll , iys , & & ixs , i_move , n_total real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), er , t , & & forward_real ( npth , nnsta ), forward_imag ( npth , nnsta ), duse , ause , vuse , & & de , rand , c , aux , dpb , amp , derr , erm , & & cmoment , d_sub , a_sub , err_s , a , b , dsum , & & err_time , t_save , a_save , d_save , x , kahan_y , kahan_t , kahan_c , & & l_save , r_save , cr ( inptd ), cz ( inptd ), forward2 ( inptd ), & & slip_beg , slip_max , slip_end , angle_beg , angle_end , angle_max , & & rupt_beg , rupt_end , rupt_max , rise_time_beg , rise_time_end , rise_time_max real :: df , df_ref , rake2 , ex real * 8 :: ersum2 , omega complex :: green_subf complex * 16 :: z , z1 , z0 , forward ( npth ) ! z0 = cmplx ( 0.d0 , 0.d0 , double ) erm = 0.0 ! !  ++++++++++++++++++++++++++++++++++++++++++++++++++++ !  Here, we compute the value of the objective function, !  using the input kinematic model. ! ll = 0 df_ref = 1.0 / ( 2.0 ** lnpt ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) forward (:) = z0 ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * source ( i , ir , isl , isr ) * z z = z * z1 end do end do end do end do do i = 1 , npth forward_real ( i , ir ) = real ( forward ( i )) forward_imag ( i , ir ) = aimag ( forward ( i )) end do end do dsum = 0.0 kahan_y = 0.0 kahan_t = 0.0 kahan_c = 0.0 do i_s = 1 , n_seg do k = 1 , nxys ( i_s ) kahan_y = slip ( k , i_s ) * cniu ( k , i_s ) - kahan_c kahan_t = dsum + kahan_y kahan_c = ( kahan_t - dsum ) - kahan_y dsum = kahan_t !         dsum = dsum+slip(k, i_s)*cniu(k, i_s)    ! we may need to increase numerical precision end do end do call define_slip_field ( slip , rake ) call tlap ( rupt_time , err_time ) ! !  An iteration of the simulated annealing algorithm, over each subfault. ! ll = 0 !       begin to perturb ! do k = 1 , nnn nsub ( k ) = k end do do k = 1 , nnn - 1 nran = k do while ( nran . eq . k . or . nran . gt . nnn ) x = ran1 () nran = int ( x * ( nnn - k ) + k + 1 ) end do nbb = nsub ( nran ) nn = nsub ( k ) nsub ( k ) = nbb nsub ( nran ) = nn end do do k = 1 , nnn ll = nsub ( k ) if ( ll . gt . nnn ) stop n_total = 0 do i_ss = 1 , n_seg n_total = nxys ( i_ss ) + n_total if ( ll . le . n_total ) then i_s = i_ss ll_s = ll exit end if end do do i_ss = 1 , i_s - 1 ll_s = ll_s - nxys ( i_ss ) end do isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) ! !  make up unchange graph ! do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) - real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) - aimag ( green_subf ) z = z * z1 ! we may need to increase numerical precision end do end do dsum = dsum - slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) nn_sub = ll ! n_accept = 0 npb = np ( 4 * ( ll - 1 ) + 1 ) if ( npb . lt . 2 ) exit ! !  slip extreme values ! npb = np ( 4 * ( ll - 1 ) + 1 ) dpb = dp ( 4 * ( ll - 1 ) + 1 ) slip_beg = beg ( 4 * ( ll - 1 ) + 1 ) slip_max = ( npb - 1 ) * dpb slip_end = slip_beg + slip_max ! !  rake extreme values ! npb = np ( 4 * ( ll - 1 ) + 2 ) dpb = dp ( 4 * ( ll - 1 ) + 2 ) angle_beg = beg ( 4 * ( ll - 1 ) + 2 ) angle_max = ( npb - 1 ) * dpb angle_end = angle_beg + angle_max ! !  rupture time extreme values. ! rupt_beg = time_min ( ll_s , i_s ) rupt_end = time_max ( ll_s , i_s ) rupt_max = rupt_end - rupt_beg write ( * , * ) rupt_beg , rupt_end , rupt_max ! !  rise time parameters extreme values ! rise_time_beg = ta0 rise_time_end = ta0 + ( msou - 1 ) * dta rise_time_max = ( msou - 1 ) * dta do i_move = 1 , max_move ! !       Save values before the perturbation ! t_save = rupt_time ( ll_s , i_s ) d_save = slip ( ll_s , i_s ) a_save = rake ( ll_s , i_s ) l_save = tl ( ll_s , i_s ) r_save = tr ( ll_s , i_s ) ! !  Perturb the slip ! duse = slip_beg - 1. do while (( duse . le . slip_beg ) . or . ( duse . ge . slip_end )) call cauchy ( t , c ) duse = slip ( ll_s , i_s ) + c * slip_max end do ! !  Perturb the rake ! ause = angle_beg - 1. do while (( ause . lt . angle_beg ) . or . ( ause . gt . angle_end )) call cauchy ( t , c ) ause = rake ( ll_s , i_s ) + c * angle_max end do ! !  Perturb the rupture time. ! vuse = rupt_beg - 1. if ( rupt_max . gt . min_dt ) then do while (( vuse . lt . rupt_beg ) . or . ( vuse . gt . rupt_end )) call cauchy ( t , c ) vuse = min_dt * int (( rupt_time ( ll_s , i_s ) + c * rupt_max ) / min_dt + 0.5 ) end do else vuse = rupt_beg end if ! !  Perturb rise time parameters ! isl = 0 do while ( isl . lt . 1 . or . isl . gt . msou ) call cauchy ( t , c ) isl = int (( tl ( ll_s , i_s ) + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 end do isr = 0 do while ( isr . lt . 1 . or . isr . gt . msou ) call cauchy ( t , c ) isr = int (( tr ( ll_s , i_s ) + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 end do rake2 = ause * dpi a = duse * sin ( rake2 ) b = duse * cos ( rake2 ) ersum2 = 0.d0 do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * vuse z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !               omega = -twopi_0*df*(i-1)*vuse !               z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z cr ( i ) = real ( green_subf ) + forward_real ( i , ir ) cz ( i ) = aimag ( green_subf ) + forward_imag ( i , ir ) z = z * z1 ! we may need to increase numerical precision end do call wavelet_syn ( cr , cz , forward2 ) call misfit ( ir , forward2 , ex ) ersum2 = ersum2 + ex ! we may need to increase numerical precision end do dsum = dsum + duse * cniu ( ll_s , i_s ) cmoment = dsum * area derr = ( cmoment / cm_point ) amp = 1.0 d_sub = duse a_sub = ause call modify_slip_field ( nn_sub , d_sub , a_sub ) call lap ( err_s ) rupt_time ( ll_s , i_s ) = vuse call tlap ( rupt_time , err_time ) erm = ersum2 + derr * coef_moment + amp * err_s * coef_slip erm = erm + coef_time * err_time dsum = dsum - duse * cniu ( ll_s , i_s ) de = erm - emin ! !  Now, we update the kinematic model. ! rand = ran1 () aux = exp ( - de / t ) if ( aux . gt . rand ) then emin = erm slip ( ll_s , i_s ) = duse rake ( ll_s , i_s ) = ause rupt_time ( ll_s , i_s ) = vuse tl ( ll_s , i_s ) = ( isl - 1 ) * dta + ta0 tr ( ll_s , i_s ) = ( isr - 1 ) * dta + ta0 n_accept = n_accept + 1 else rupt_time ( ll_s , i_s ) = t_save tl ( ll_s , i_s ) = l_save tr ( ll_s , i_s ) = r_save slip ( ll_s , i_s ) = d_save rake ( ll_s , i_s ) = a_save end if ermin = min ( ermin , erm ) if ( n_accept . gt . accept_max ) exit end do ! !  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !  finish the perturbation of subevent (i_s, ll_s) ! rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 dsum = dsum + slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) d_sub = slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) nn_sub = ll call modify_slip_field ( nn_sub , d_sub , a_sub ) call tlap ( rupt_time , err_time ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) & & * source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) + real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) + aimag ( green_subf ) z = z * z1 end do end do end do write ( * , * ) ermin end subroutine annealing_iter subroutine annealing_iter2 ( slip , rake , rupt_time , tl , tr , er , t ) !! !!  We compute an iteration of the annealing method, adding static GPS data. !!  Non-parallelized version. !! implicit none integer isl , isr , nn_sub , nsub ( nnxy_m ), n_accept , & & nbb , i , k , npb , nn , nran , ll_s , i_s , i_ss , ir , ll , iys , & & ixs , i_move , n_total real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), er , t , & & forward_real ( npth , nnsta ), forward_imag ( npth , nnsta ), duse , ause , vuse , & & de , rand , c , aux , dpb , amp , derr , erm , err_static , & & cmoment , d_sub , a_sub , err_s , a , b , dsum , & & err_time , t_save , a_save , d_save , x , kahan_y , kahan_t , kahan_c , & & l_save , r_save , cr ( inptd ), cz ( inptd ), forward2 ( inptd ), & & slip_beg , slip_max , slip_end , angle_beg , angle_end , angle_max , & & rupt_beg , rupt_end , rupt_max , rise_time_beg , rise_time_end , rise_time_max real :: df , df_ref , rake2 , ex real * 8 :: omega , ersum2 complex :: green_subf complex * 16 :: z , z1 , forward ( npth ), z0 ! z0 = cmplx ( 0.d0 , 0.d0 , double ) erm = 0.0 ! !  ++++++++++++++++++++++++++++++++++++++++++++++++++++ !  Here, we compute the value of the objective function, !  using the input kinematic model. ! ll = 0 df_ref = 1.0 / ( 2.0 ** lnpt ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) forward (:) = z0 ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * source ( i , ir , isl , isr ) * z z = z * z1 ! we may need to increase numerical precision end do end do end do end do do i = 1 , npth forward_real ( i , ir ) = real ( forward ( i )) forward_imag ( i , ir ) = aimag ( forward ( i )) end do end do call static_synthetic ( slip , rake , nxys , err_static ) dsum = 0.0 kahan_y = 0.0 kahan_t = 0.0 kahan_c = 0.0 do i_s = 1 , n_seg do k = 1 , nxys ( i_s ) kahan_y = slip ( k , i_s ) * cniu ( k , i_s ) - kahan_c kahan_t = dsum + kahan_y kahan_c = ( kahan_t - dsum ) - kahan_y dsum = kahan_t !         dsum = dsum+slip(k, i_s)*cniu(k, i_s)    ! we may need to increase numerical precision end do end do call define_slip_field ( slip , rake ) call tlap ( rupt_time , err_time ) ! !  An iteration of the simulated annealing algorithm, over each subfault. ! ll = 0 !       begin to perturb ! do k = 1 , nnn nsub ( k ) = k end do do k = 1 , nnn - 1 nran = k do while ( nran . eq . k . or . nran . gt . nnn ) x = ran1 () nran = int ( x * ( nnn - k ) + k + 1 ) end do nbb = nsub ( nran ) nn = nsub ( k ) nsub ( k ) = nbb nsub ( nran ) = nn end do do k = 1 , nnn ll = nsub ( k ) if ( ll . gt . nnn ) stop n_total = 0 do i_ss = 1 , n_seg n_total = nxys ( i_ss ) + n_total if ( ll . le . n_total ) then i_s = i_ss ll_s = ll exit end if end do do i_ss = 1 , i_s - 1 ll_s = ll_s - nxys ( i_ss ) end do isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) ! !  make up unchange graph ! do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) - real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) - aimag ( green_subf ) z = z * z1 ! we may need to increase numerical precision end do end do call static_remove_subfault ( slip , rake , i_s , ll_s ) dsum = dsum - slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) nn_sub = ll ! n_accept = 0 npb = np ( 4 * ( ll - 1 ) + 1 ) if ( npb . lt . 2 ) exit ! !  slip extreme values ! npb = np ( 4 * ( ll - 1 ) + 1 ) dpb = dp ( 4 * ( ll - 1 ) + 1 ) slip_beg = beg ( 4 * ( ll - 1 ) + 1 ) slip_max = ( npb - 1 ) * dpb slip_end = slip_beg + slip_max ! !  rake extreme values ! npb = np ( 4 * ( ll - 1 ) + 2 ) dpb = dp ( 4 * ( ll - 1 ) + 2 ) angle_beg = beg ( 4 * ( ll - 1 ) + 2 ) angle_max = ( npb - 1 ) * dpb angle_end = angle_beg + angle_max ! !  rupture time extreme values. ! rupt_beg = time_min ( ll_s , i_s ) rupt_end = time_max ( ll_s , i_s ) rupt_max = rupt_end - rupt_beg ! !  rise time parameters extreme values ! rise_time_beg = ta0 rise_time_end = ta0 + ( msou - 1 ) * dta rise_time_max = ( msou - 1 ) * dta do i_move = 1 , max_move ! !       Save values before the perturbation ! t_save = rupt_time ( ll_s , i_s ) d_save = slip ( ll_s , i_s ) a_save = rake ( ll_s , i_s ) l_save = tl ( ll_s , i_s ) r_save = tr ( ll_s , i_s ) ! !  Perturb the slip ! duse = slip_beg - 1. do while (( duse . le . slip_beg ) . or . ( duse . ge . slip_end )) call cauchy ( t , c ) duse = d_save + c * slip_max end do ! !  Perturb the rake ! ause = angle_beg - 1. do while (( ause . lt . angle_beg ) . or . ( ause . gt . angle_end )) call cauchy ( t , c ) ause = a_save + c * angle_max end do ! !  Perturb the rupture time. ! vuse = rupt_beg - 1. if ( rupt_max . gt . min_dt ) then do while (( vuse . lt . rupt_beg ) . or . ( vuse . gt . rupt_end )) call cauchy ( t , c ) vuse = min_dt * int (( t_save + c * rupt_max ) / min_dt + 0.5 ) end do else vuse = rupt_beg end if ! !  Perturb rise time parameters ! isl = 0 do while ( isl . lt . 1 . or . isl . gt . msou ) call cauchy ( t , c ) isl = int (( l_save + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 end do isr = 0 do while ( isr . lt . 1 . or . isr . gt . msou ) call cauchy ( t , c ) isr = int (( r_save + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 end do rake2 = ause * dpi a = duse * sin ( rake2 ) b = duse * cos ( rake2 ) ersum2 = 0.d0 do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * vuse z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !               omega = -twopi_0*df*(i-1)*vuse !               z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z cr ( i ) = real ( green_subf ) + forward_real ( i , ir ) cz ( i ) = aimag ( green_subf ) + forward_imag ( i , ir ) z = z * z1 ! we may need to increase numerical precision end do call wavelet_syn ( cr , cz , forward2 ) call misfit ( ir , forward2 , ex ) ersum2 = ersum2 + ex ! we may need to increase numerical precision end do call static_modify_subfault ( duse , ause , i_s , ll_s , err_static ) dsum = dsum + duse * cniu ( ll_s , i_s ) cmoment = dsum * area derr = ( cmoment / cm_point ) amp = 1.0 d_sub = duse a_sub = ause call modify_slip_field ( nn_sub , d_sub , a_sub ) call lap ( err_s ) rupt_time ( ll_s , i_s ) = vuse call tlap ( rupt_time , err_time ) erm = ersum2 + derr * coef_moment + amp * err_s * coef_slip erm = erm + coef_time * err_time + coef_st * err_static dsum = dsum - duse * cniu ( ll_s , i_s ) de = erm - emin ! !  Now, we update the kinematic model. ! rand = ran1 () aux = exp ( - de / t ) if ( k . eq . 1 ) then write ( * , * ) i_move , ersum2 , err_s , err_static , err_time write ( * , * ) n_accept end if if ( aux . gt . rand ) then emin = erm slip ( ll_s , i_s ) = duse rake ( ll_s , i_s ) = ause rupt_time ( ll_s , i_s ) = vuse tl ( ll_s , i_s ) = ( isl - 1 ) * dta + ta0 tr ( ll_s , i_s ) = ( isr - 1 ) * dta + ta0 n_accept = n_accept + 1 else rupt_time ( ll_s , i_s ) = t_save tl ( ll_s , i_s ) = l_save tr ( ll_s , i_s ) = r_save slip ( ll_s , i_s ) = d_save rake ( ll_s , i_s ) = a_save end if ermin = min ( ermin , erm ) if ( n_accept . gt . accept_max ) exit end do ! !  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !  finish the perturbation of subevent (i_s, ll_s) ! rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 dsum = dsum + slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) d_sub = slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) nn_sub = ll call modify_slip_field ( nn_sub , d_sub , a_sub ) call tlap ( rupt_time , err_time ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !            omega = -twopi_0*df*(i-1)*rupt_time(ll_s, i_s) !            z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) & & * source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) + real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) + aimag ( green_subf ) z = z * z1 end do end do call static_add_subfault ( slip , rake , i_s , ll_s , err_static ) end do write ( * , * ) ermin end subroutine annealing_iter2 subroutine annealing_iter3 ( slip , rake , rupt_time , tl , tr , er , t ) !! !!  We compute an iteration of the annealing method. !!  Parallelized version. !! use omp_lib implicit none integer isl , isr , nn_sub , nsub ( nnxy_m ), n_accept , & & nbb , i , k , npb , nn , nran , ll_s , i_s , i_ss , ir , ll , iys , & & ixs , i_move , n_total real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), er , t , & & forward_real ( npth , nnsta ), forward_imag ( npth , nnsta ), duse , ause , vuse , & & de , rand , c , aux , dpb , amp , derr , erm , err_static , & & cmoment , d_sub , a_sub , err_s , a , b , dsum , & & err_time , t_save , a_save , d_save , x , kahan_y , kahan_t , kahan_c , & & l_save , r_save , cr ( inptd ), cz ( inptd ), forward2 ( inptd ), & & slip_beg , slip_max , slip_end , angle_beg , angle_end , angle_max , & & rupt_beg , rupt_end , rupt_max , rise_time_beg , rise_time_end , rise_time_max real :: df_ref , df , rake2 , ex real * 8 :: omega , ersum2 complex :: green_subf complex * 16 :: z , z1 , forward ( npth ), z0 ! z0 = cmplx ( 0.d0 , 0.d0 , double ) erm = 0.0 ! !  ++++++++++++++++++++++++++++++++++++++++++++++++++++ !  Here, we compute the value of the objective function, !  using the input kinematic model. ! ll = 0 df_ref = 1.0 / ( 2.0 ** lnpt ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) forward (:) = z0 ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * source ( i , ir , isl , isr ) * z z = z * z1 ! we may need to increase numerical precision end do end do end do end do do i = 1 , npth forward_real ( i , ir ) = real ( forward ( i )) forward_imag ( i , ir ) = aimag ( forward ( i )) end do end do dsum = 0.0 kahan_y = 0.0 kahan_t = 0.0 kahan_c = 0.0 do i_s = 1 , n_seg do k = 1 , nxys ( i_s ) kahan_y = slip ( k , i_s ) * cniu ( k , i_s ) - kahan_c kahan_t = dsum + kahan_y kahan_c = ( kahan_t - dsum ) - kahan_y dsum = kahan_t !         dsum = dsum+slip(k, i_s)*cniu(k, i_s)    ! we may need to increase numerical precision end do end do call define_slip_field ( slip , rake ) call tlap ( rupt_time , err_time ) ! !  An iteration of the simulated annealing algorithm, over each subfault. ! ll = 0 !       begin to perturb ! do k = 1 , nnn nsub ( k ) = k end do do k = 1 , nnn - 1 nran = k do while ( nran . eq . k . or . nran . gt . nnn ) x = ran1 () nran = int ( x * ( nnn - k ) + k + 1 ) end do nbb = nsub ( nran ) nn = nsub ( k ) nsub ( k ) = nbb nsub ( nran ) = nn end do do k = 1 , nnn ll = nsub ( k ) if ( ll . gt . nnn ) stop n_total = 0 do i_ss = 1 , n_seg n_total = nxys ( i_ss ) + n_total if ( ll . le . n_total ) then i_s = i_ss ll_s = ll exit end if end do do i_ss = 1 , i_s - 1 ll_s = ll_s - nxys ( i_ss ) end do isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) ! !  make up unchange graph ! do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !            omega = -twopi_0*df*(i-1)*rupt_time(ll_s, i_s) !            z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) - real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) - aimag ( green_subf ) z = z * z1 ! we may need to increase numerical precision end do end do dsum = dsum - slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) nn_sub = ll ! n_accept = 0 npb = np ( 4 * ( ll - 1 ) + 1 ) if ( npb . lt . 2 ) exit ! !  slip extreme values ! npb = np ( 4 * ( ll - 1 ) + 1 ) dpb = dp ( 4 * ( ll - 1 ) + 1 ) slip_beg = beg ( 4 * ( ll - 1 ) + 1 ) slip_max = ( npb - 1 ) * dpb slip_end = slip_beg + slip_max ! !  rake extreme values ! npb = np ( 4 * ( ll - 1 ) + 2 ) dpb = dp ( 4 * ( ll - 1 ) + 2 ) angle_beg = beg ( 4 * ( ll - 1 ) + 2 ) angle_max = ( npb - 1 ) * dpb angle_end = angle_beg + angle_max ! !  rupture time extreme values. ! rupt_beg = time_min ( ll_s , i_s ) rupt_end = time_max ( ll_s , i_s ) rupt_max = rupt_end - rupt_beg ! !  rise time parameters extreme values ! rise_time_beg = ta0 rise_time_end = ta0 + ( msou - 1 ) * dta rise_time_max = ( msou - 1 ) * dta do i_move = 1 , max_move ! !       Save values before the perturbation ! t_save = rupt_time ( ll_s , i_s ) d_save = slip ( ll_s , i_s ) a_save = rake ( ll_s , i_s ) l_save = tl ( ll_s , i_s ) r_save = tr ( ll_s , i_s ) ! !  Perturb the slip ! call cauchy ( t , c ) duse = d_save + c * slip_max duse = min ( duse , slip_end ) duse = max ( duse , slip_beg ) ! !  Perturb the rake ! call cauchy ( t , c ) ause = a_save + c * angle_max ause = min ( ause , angle_end ) ause = max ( ause , angle_beg ) ! !  Perturb the rupture time. ! if ( rupt_max . gt . min_dt ) then call cauchy ( t , c ) vuse = min_dt * int (( t_save + c * rupt_max ) / min_dt + 0.5 ) vuse = min ( vuse , rupt_end ) vuse = max ( vuse , rupt_beg ) else vuse = rupt_beg end if ! !  Perturb rise time parameters ! call cauchy ( t , c ) isl = int (( l_save + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 isl = min0 ( isl , msou ) isl = max0 ( isl , 1 ) call cauchy ( t , c ) isr = int (( r_save + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 isr = min0 ( isr , msou ) isr = max0 ( isr , 1 ) rake2 = ause * dpi a = duse * sin ( rake2 ) b = duse * cos ( rake2 ) ersum2 = 0.d0 !$omp parallel & !$omp& default(shared) & !$omp& private(ir, df, i, omega, z, z1, green_subf, cr, cz, forward2, ex) !$omp do schedule(guided) reduction(+:ersum2) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * vuse z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !               omega = -twopi_0*df*(i-1)*vuse !               z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z cr ( i ) = real ( green_subf ) + forward_real ( i , ir ) cz ( i ) = aimag ( green_subf ) + forward_imag ( i , ir ) z = z * z1 ! we may need to increase numerical precision end do call wavelet_syn ( cr , cz , forward2 ) call misfit ( ir , forward2 , ex ) ersum2 = ersum2 + ex ! we may need to increase numerical precision end do !$omp end do !$omp end parallel dsum = dsum + duse * cniu ( ll_s , i_s ) cmoment = dsum * area derr = ( cmoment / cm_point ) amp = 1.0 call modify_slip_field ( nn_sub , duse , ause ) call lap ( err_s ) rupt_time ( ll_s , i_s ) = vuse call tlap ( rupt_time , err_time ) erm = ersum2 + derr * coef_moment + amp * err_s * coef_slip erm = erm + coef_time * err_time + coef_st * err_static dsum = dsum - duse * cniu ( ll_s , i_s ) de = erm - emin ! !  Now, we update the kinematic model. ! rand = ran1 () aux = exp ( - de / t ) if ( aux . gt . rand ) then emin = erm slip ( ll_s , i_s ) = duse rake ( ll_s , i_s ) = ause rupt_time ( ll_s , i_s ) = vuse tl ( ll_s , i_s ) = ( isl - 1 ) * dta + ta0 tr ( ll_s , i_s ) = ( isr - 1 ) * dta + ta0 n_accept = n_accept + 1 else rupt_time ( ll_s , i_s ) = t_save tl ( ll_s , i_s ) = l_save tr ( ll_s , i_s ) = r_save slip ( ll_s , i_s ) = d_save rake ( ll_s , i_s ) = a_save end if ermin = min ( ermin , erm ) if ( n_accept . gt . accept_max ) exit end do ! !  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !  finish the perturbation of subevent (i_s, ll_s) ! rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 dsum = dsum + slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) d_sub = slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) nn_sub = ll call modify_slip_field ( nn_sub , d_sub , a_sub ) call tlap ( rupt_time , err_time ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !            omega = -twopi_0*df*(i-1)*rupt_time(ll_s, i_s) !            z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) & & * source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) + real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) + aimag ( green_subf ) z = z * z1 end do end do end do write ( * , * ) ermin end subroutine annealing_iter3 subroutine annealing_iter4 ( slip , rake , rupt_time , tl , tr , er , t ) !! !!  We compute an iteration of the annealing method, adding static GPS data. !!  Parallelized version. !! use omp_lib implicit none integer isl , isr , nn_sub , nsub ( nnxy_m ), n_accept , & & nbb , i , k , npb , nn , nran , ll_s , i_s , i_ss , ir , ll , iys , & & ixs , i_move , n_total real slip ( nnxy , max_seg ), rake ( nnxy , max_seg ), rupt_time ( nnxy , max_seg ), & & tr ( nnxy , max_seg ), tl ( nnxy , max_seg ), er , t , & & forward_real ( npth , nnsta ), forward_imag ( npth , nnsta ), duse , ause , vuse , & & de , rand , c , aux , dpb , amp , derr , erm , err_static , & & cmoment , d_sub , a_sub , err_s , a , b , kahan_y , kahan_c , kahan_t , & & err_time , t_save , a_save , d_save , x , dsum , & & l_save , r_save , cr ( inptd ), cz ( inptd ), forward2 ( inptd ), & & slip_beg , slip_max , slip_end , angle_beg , angle_end , angle_max , & & rupt_beg , rupt_end , rupt_max , rise_time_beg , rise_time_end , rise_time_max real * 8 :: omega , ersum2 real :: df , df_ref , rake2 , ex complex :: green_subf complex * 16 :: z , z1 , forward ( npth ), z0 ! z0 = cmplx ( 0.d0 , 0.d0 , double ) erm = 0.0 ! !  ++++++++++++++++++++++++++++++++++++++++++++++++++++ !  Here, we compute the value of the objective function, !  using the input kinematic model. ! ll = 0 df_ref = 1.0 / ( 2.0 ** lnpt ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) forward (:) = z0 ll = 0 do i_s = 1 , n_seg do iys = 1 , nys_sub ( i_s ) do ixs = 1 , nxs_sub ( i_s ) ll = ll + 1 ll_s = ( iys - 1 ) * nxs_sub ( i_s ) + ixs rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax forward ( i ) = forward ( i ) & & + ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * source ( i , ir , isl , isr ) * z z = z * z1 ! we may need to increase numerical precision end do end do end do end do do i = 1 , npth forward_real ( i , ir ) = real ( forward ( i )) forward_imag ( i , ir ) = aimag ( forward ( i )) end do end do call static_synthetic ( slip , rake , nxys , err_static ) dsum = 0.0 kahan_y = 0.0 kahan_t = 0.0 kahan_c = 0.0 do i_s = 1 , n_seg do k = 1 , nxys ( i_s ) kahan_y = slip ( k , i_s ) * cniu ( k , i_s ) - kahan_c kahan_t = dsum + kahan_y kahan_c = ( kahan_t - dsum ) - kahan_y dsum = kahan_t !         dsum = dsum+slip(k, i_s)*cniu(k, i_s)    ! we may need to increase numerical precision end do end do call define_slip_field ( slip , rake ) call tlap ( rupt_time , err_time ) ! !  An iteration of the simulated annealing algorithm, over each subfault. ! ll = 0 !       begin to perturb ! do k = 1 , nnn nsub ( k ) = k end do do k = 1 , nnn - 1 nran = k do while ( nran . eq . k . or . nran . gt . nnn ) x = ran1 () nran = int ( x * ( nnn - k ) + k + 1 ) end do nbb = nsub ( nran ) nn = nsub ( k ) nsub ( k ) = nbb nsub ( nran ) = nn end do do k = 1 , nnn ll = nsub ( k ) if ( ll . gt . nnn ) stop n_total = 0 do i_ss = 1 , n_seg n_total = nxys ( i_ss ) + n_total if ( ll . le . n_total ) then i_s = i_ss ll_s = ll exit end if end do do i_ss = 1 , i_s - 1 ll_s = ll_s - nxys ( i_ss ) end do isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) ! !  make up unchange graph ! do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !            omega = -twopi_0*df*(i-1)*rupt_time(ll_s, i_s) !            z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) - real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) - aimag ( green_subf ) z = z * z1 ! we may need to increase numerical precision end do end do call static_remove_subfault ( slip , rake , i_s , ll_s ) dsum = dsum - slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) nn_sub = ll ! n_accept = 0 npb = np ( 4 * ( ll - 1 ) + 1 ) if ( npb . lt . 2 ) exit ! !  slip extreme values ! npb = np ( 4 * ( ll - 1 ) + 1 ) dpb = dp ( 4 * ( ll - 1 ) + 1 ) slip_beg = beg ( 4 * ( ll - 1 ) + 1 ) slip_max = ( npb - 1 ) * dpb slip_end = slip_beg + slip_max ! !  rake extreme values ! npb = np ( 4 * ( ll - 1 ) + 2 ) dpb = dp ( 4 * ( ll - 1 ) + 2 ) angle_beg = beg ( 4 * ( ll - 1 ) + 2 ) angle_max = ( npb - 1 ) * dpb angle_end = angle_beg + angle_max ! !  rupture time extreme values. ! rupt_beg = time_min ( ll_s , i_s ) rupt_end = time_max ( ll_s , i_s ) rupt_max = rupt_end - rupt_beg ! !  rise time parameters extreme values ! rise_time_beg = ta0 rise_time_end = ta0 + ( msou - 1 ) * dta rise_time_max = ( msou - 1 ) * dta do i_move = 1 , max_move ! !       Save values before the perturbation ! t_save = rupt_time ( ll_s , i_s ) d_save = slip ( ll_s , i_s ) a_save = rake ( ll_s , i_s ) l_save = tl ( ll_s , i_s ) r_save = tr ( ll_s , i_s ) ! !  Perturb the slip ! call cauchy ( t , c ) duse = d_save + c * slip_max duse = min ( duse , slip_end ) duse = max ( duse , slip_beg ) ! !  Perturb the rake ! call cauchy ( t , c ) ause = a_save + c * angle_max ause = min ( ause , angle_end ) ause = max ( ause , angle_beg ) ! !  Perturb the rupture time. ! if ( rupt_max . gt . min_dt ) then call cauchy ( t , c ) vuse = min_dt * int (( t_save + c * rupt_max ) / min_dt + 0.5 ) vuse = min ( vuse , rupt_end ) vuse = max ( vuse , rupt_beg ) else vuse = rupt_beg end if ! !  Perturb rise time parameters ! call cauchy ( t , c ) isl = int (( l_save + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 isl = min0 ( isl , msou ) isl = max0 ( isl , 1 ) call cauchy ( t , c ) isr = int (( r_save + c * rise_time_max - ta0 ) / dta + 0.5 ) + 1 isr = min0 ( isr , msou ) isr = max0 ( isr , 1 ) rake2 = ause * dpi a = duse * sin ( rake2 ) b = duse * cos ( rake2 ) ersum2 = 0.d0 !$omp parallel & !$omp& default(shared) & !$omp& private(ir, df, i, omega, z, z1, green_subf, cr, cz, forward2, ex) !$omp do schedule(guided) reduction(+:ersum2) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * vuse z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) * & & source ( i , ir , isl , isr ) * z cr ( i ) = real ( green_subf ) + forward_real ( i , ir ) cz ( i ) = aimag ( green_subf ) + forward_imag ( i , ir ) z = z * z1 ! we may need to increase numerical precision end do call wavelet_syn ( cr , cz , forward2 ) call misfit ( ir , forward2 , ex ) ersum2 = ersum2 + ex ! we may need to increase numerical precision end do !$omp end do !$omp end parallel dsum = dsum + duse * cniu ( ll_s , i_s ) cmoment = dsum * area derr = ( cmoment / cm_point ) amp = 1.0 call static_modify_subfault ( duse , ause , i_s , ll_s , err_static ) call modify_slip_field ( nn_sub , duse , ause ) call lap ( err_s ) rupt_time ( ll_s , i_s ) = vuse call tlap ( rupt_time , err_time ) erm = ersum2 + derr * coef_moment + amp * err_s * coef_slip erm = erm + coef_time * err_time + coef_st * err_static dsum = dsum - duse * cniu ( ll_s , i_s ) de = erm - emin ! !  Now, we update the kinematic model. ! rand = ran1 () aux = exp ( - de / t ) if ( aux . gt . rand ) then emin = erm slip ( ll_s , i_s ) = duse rake ( ll_s , i_s ) = ause rupt_time ( ll_s , i_s ) = vuse tl ( ll_s , i_s ) = ( isl - 1 ) * dta + ta0 tr ( ll_s , i_s ) = ( isr - 1 ) * dta + ta0 n_accept = n_accept + 1 else rupt_time ( ll_s , i_s ) = t_save tl ( ll_s , i_s ) = l_save tr ( ll_s , i_s ) = r_save slip ( ll_s , i_s ) = d_save rake ( ll_s , i_s ) = a_save end if ermin = min ( ermin , erm ) if ( n_accept . gt . accept_max ) exit end do ! !  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !  finish the perturbation of subevent (i_s, ll_s) ! rake2 = rake ( ll_s , i_s ) * dpi a = sin ( rake2 ) * slip ( ll_s , i_s ) b = cos ( rake2 ) * slip ( ll_s , i_s ) isl = int (( tl ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 isr = int (( tr ( ll_s , i_s ) - ta0 ) / dta + 0.5 ) + 1 dsum = dsum + slip ( ll_s , i_s ) * cniu ( ll_s , i_s ) d_sub = slip ( ll_s , i_s ) a_sub = rake ( ll_s , i_s ) nn_sub = ll call modify_slip_field ( nn_sub , d_sub , a_sub ) call tlap ( rupt_time , err_time ) do ir = 1 , n_chan df = df_ref / dt_channel ( ir ) omega = - twopi * df * rupt_time ( ll_s , i_s ) z1 = cmplx ( cos ( omega ), sin ( omega ), double ) z = cmplx ( 1.d0 , 0.d0 , double ) do i = 1 , jfmax !            omega = -twopi_0*df*(i-1)*rupt_time(ll_s, i_s) !            z = cmplx(cos(omega), sin(omega)) green_subf = ( a * green_dip ( i , ir , ll ) + b * green_stk ( i , ir , ll )) & & * source ( i , ir , isl , isr ) * z forward_real ( i , ir ) = forward_real ( i , ir ) + real ( green_subf ) forward_imag ( i , ir ) = forward_imag ( i , ir ) + aimag ( green_subf ) z = z * z1 end do end do call static_add_subfault ( slip , rake , i_s , ll_s , err_static ) end do write ( * , * ) ermin end subroutine annealing_iter4 end module annealing","title":"annealing.f95 – Kinematic modelling","tags":""},{"loc":"sourcefile/rad_pattern.f95.html","text":"Contents Modules rad_pattern Source Code rad_pattern.f95 Source Code module rad_pattern use constants , only : dpi implicit none contains subroutine rad_coef ( dip , theta , az , ang_d , coef_v , coef_r ) !! !!   Eight Green´s function in the sequence SS DS SS DS DD SS DS DD !! real ( 8 ) :: coef_v ( 2 , 3 ), coef_r ( 2 , 5 ), dip , theta , az , ang_d real ( 8 ) :: source_az , source_az2 , dip_rad , dip_rad2 , rad_rot , tan_rot real ( 8 ) :: sind , cosd , sin2d , cos2d , sinaz , cosaz , sin2az , cos2az ang_d = - ang_d * dpi rad_rot = cos ( ang_d ) tan_rot = - sin ( ang_d ) dip_rad = dip * dpi dip_rad2 = 2.d0 * dip_rad sind = sin ( dip_rad ) cosd = cos ( dip_rad ) sin2d = sin ( dip_rad2 ) cos2d = cos ( dip_rad2 ) source_az = ( az - theta ) * dpi source_az2 = 2.d0 * source_az sinaz = sin ( source_az ) cosaz = cos ( source_az ) sin2az = sin ( source_az2 ) cos2az = cos ( source_az2 ) ! ! vertical components ! coef_v ( 1 , 1 ) = 0.5d0 * sin2d * cos2az ! vertical SS, multiplied by -1? coef_v ( 1 , 2 ) = - sinaz * cos2d ! vertical DS coef_v ( 1 , 3 ) = 0.5d0 * sin2d ! vertical 45DS coef_v ( 2 , 1 ) = sind * sin2az ! vertical SS, multiplied by -1? coef_v ( 2 , 2 ) = cosaz * cosd ! vertical DS coef_v ( 2 , 3 ) = 0.d0 ! vertical 45DS ! ! horizontal components ! coef_r ( 1 , 1 ) = - 0.5d0 * sin2d * sin2az * tan_rot ! tangential SS, rotated by rad_c coef_r ( 1 , 2 ) = - cosaz * cos2d * tan_rot ! tangential DS, rotated by rad_c, multiplied by -1? coef_r ( 1 , 3 ) = 0.5d0 * sin2d * cos2az * rad_rot ! radial SS, rotated by rad_c, multiplied by -1? coef_r ( 1 , 4 ) = - sinaz * cos2d * rad_rot ! radial DS, rotated by rad_c. coef_r ( 1 , 5 ) = 0.5d0 * sin2d * rad_rot ! radial 45DS rotated by rad_c coef_r ( 2 , 1 ) = sind * cos2az * tan_rot ! tangential SS, rotated by rad_c coef_r ( 2 , 2 ) = - sinaz * cosd * tan_rot ! tangential DS, rotated by rad_c, multiplied by -1? coef_r ( 2 , 3 ) = sind * sin2az * rad_rot ! radial SS, rotated by rad_c, multiplied by -1? coef_r ( 2 , 4 ) = cosaz * cosd * rad_rot ! radial DS, rotated by rad_c coef_r ( 2 , 5 ) = 0.d0 ! radial 45, rotated by rad_c end subroutine rad_coef end module rad_pattern","title":"rad_pattern.f95 – Kinematic modelling","tags":""},{"loc":"proc/realtr.html","text":"public subroutine realtr(xr, xi, n) Arguments Type Intent Optional Attributes Name real :: xr (*) real :: xi (*) integer :: n Contents None","title":"realtr – Kinematic modelling","tags":""},{"loc":"proc/fft.html","text":"public subroutine fft(xr, xi, n, sn) Fast Fourier transform. Arguments Type Intent Optional Attributes Name real :: xr (*) real :: xi (*) integer :: n real :: sn Contents None","title":"fft – Kinematic modelling","tags":""},{"loc":"proc/fourier_asym_cosine.html","text":"public subroutine fourier_asym_cosine(omega, t1, t2, source) Analitic fourier transform of asymmetric cosine Arguments Type Intent Optional Attributes Name real :: omega real :: t1 real :: t2 complex :: source Contents None","title":"fourier_asym_cosine – Kinematic modelling","tags":""},{"loc":"proc/get_source_fun.html","text":"public subroutine get_source_fun() We load to memory, the Fourier transform of rise time function Arguments None Contents None","title":"get_source_fun – Kinematic modelling","tags":""},{"loc":"proc/deallocate_source.html","text":"public subroutine deallocate_source() Arguments None Contents None","title":"deallocate_source – Kinematic modelling","tags":""},{"loc":"proc/interp_gf.html","text":"public function interp_gf(distance, depth, d_min, d_max, zu_min, zu_max) result(green_out) Get GF at a given location and depth, as the average of the 4 closest\n  GF in the distance-depth grid. Arguments Type Intent Optional Attributes Name real(kind=8) :: distance real :: depth real :: d_min real :: d_max real :: zu_min real :: zu_max Return Value complex\n  (inptd,10) Contents None","title":"interp_gf – Kinematic modelling","tags":""},{"loc":"proc/get_surf_gf_data.html","text":"public subroutine get_surf_gf_data(gf_file, gf_bank) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: gf_file character(len=100), intent(out) :: gf_bank Contents None","title":"get_surf_gf_data – Kinematic modelling","tags":""},{"loc":"proc/get_surf_gf.html","text":"public subroutine get_surf_gf(gf_bank, d_min, d_max, z_min, z_max) Load to memory GF bank, from a specified location. Arguments Type Intent Optional Attributes Name character(len=100) :: gf_bank real :: d_min real :: d_max real :: z_min real :: z_max Contents None","title":"get_surf_gf – Kinematic modelling","tags":""},{"loc":"proc/grid_properties.html","text":"public subroutine grid_properties() Arguments None Contents None","title":"grid_properties – Kinematic modelling","tags":""},{"loc":"proc/get_subgrid_bounds.html","text":"public subroutine get_subgrid_bounds(fault_bounds, nx_b, nx_e, nz_b, nz_e) Arguments Type Intent Optional Attributes Name real, intent(in) :: fault_bounds (2,2) integer, intent(out) :: nx_b integer, intent(out) :: nx_e integer, intent(out) :: nz_b integer, intent(out) :: nz_e Contents None","title":"get_subgrid_bounds – Kinematic modelling","tags":""},{"loc":"proc/get_subgrid.html","text":"public subroutine get_subgrid(fault_bounds, subgrid_dist, subgrid_depth) Arguments Type Intent Optional Attributes Name real, intent(in) :: fault_bounds (2,2) real, intent(out) :: subgrid_dist (1601) real, intent(out) :: subgrid_depth (20) Contents None","title":"get_subgrid – Kinematic modelling","tags":""},{"loc":"proc/wave.html","text":"public function wave(w, ic) result(wave1) Meyer wavelet function in frequency domain. Arguments Type Intent Optional Attributes Name real(kind=8) :: w integer :: ic Return Value complex Contents None","title":"wave – Kinematic modelling","tags":""},{"loc":"proc/wavelet_obs.html","text":"public subroutine wavelet_obs(cr, cz, u) Compute wavelet transform. Input data is in time domain Arguments Type Intent Optional Attributes Name real :: cr (inptd) real :: cz (inptd) real :: u (inptd) Contents None","title":"wavelet_obs – Kinematic modelling","tags":""},{"loc":"proc/wavelet_syn.html","text":"public pure subroutine wavelet_syn(cr, cz, u) Compute wavelet transform. Input data is in frequency domain Arguments Type Intent Optional Attributes Name real, intent(inout) :: cr (inptd) real, intent(inout) :: cz (inptd) real, intent(out) :: u (inptd) Contents None","title":"wavelet_syn – Kinematic modelling","tags":""},{"loc":"proc/cfft.html","text":"public pure subroutine cfft(xr, xi, n) Fast Fourier transform Arguments Type Intent Optional Attributes Name real, intent(inout) :: xr (*) real, intent(inout) :: xi (*) integer, intent(in) :: n Contents None","title":"cfft – Kinematic modelling","tags":""},{"loc":"proc/cifft.html","text":"public pure subroutine cifft(xr, xi, n) Inverse Fast Fourier transform Arguments Type Intent Optional Attributes Name real, intent(inout) :: xr (*) real, intent(inout) :: xi (*) integer, intent(in) :: n Contents None","title":"cifft – Kinematic modelling","tags":""},{"loc":"proc/fourier_coefs.html","text":"public subroutine fourier_coefs() We load into memory certain values of sine and cosine, frequently used in computing the\n  Fast Fourier Transform. Arguments None Contents None","title":"fourier_coefs – Kinematic modelling","tags":""},{"loc":"proc/meyer_yamada.html","text":"public subroutine meyer_yamada() We load into memory the values of the Meyer wavelet function, \n   which are used when computing the wavelet transform of an input data. Arguments None Contents None","title":"meyer_yamada – Kinematic modelling","tags":""},{"loc":"proc/realtr~2.html","text":"public subroutine realtr(xr, xi, n) Arguments Type Intent Optional Attributes Name real :: xr (*) real :: xi (*) integer :: n Contents None","title":"realtr – Kinematic modelling","tags":""},{"loc":"proc/get_data.html","text":"public subroutine get_data(strong, cgps, body, surf, dart) We load into memory, wavelet transform of observed data, and \n  other properties of stations Arguments Type Intent Optional Attributes Name logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart Contents None","title":"get_data – Kinematic modelling","tags":""},{"loc":"proc/get_strong_motion_stations.html","text":"public subroutine get_strong_motion_stations(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_strong_motion_stations – Kinematic modelling","tags":""},{"loc":"proc/get_cgps_stations.html","text":"public subroutine get_cgps_stations(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_cgps_stations – Kinematic modelling","tags":""},{"loc":"proc/get_body_waves_stations.html","text":"public subroutine get_body_waves_stations(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_body_waves_stations – Kinematic modelling","tags":""},{"loc":"proc/get_surface_waves_stations.html","text":"public subroutine get_surface_waves_stations(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_surface_waves_stations – Kinematic modelling","tags":""},{"loc":"proc/get_dart_stations.html","text":"public subroutine get_dart_stations(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_dart_stations – Kinematic modelling","tags":""},{"loc":"proc/ran1.html","text":"public function ran1() result(random) Arguments None Return Value real Contents None","title":"ran1 – Kinematic modelling","tags":""},{"loc":"proc/ran3.html","text":"public function ran3() result(random) *  routine to generate a uniformly distributed random *  number on the interval [0, 1]. Arguments None Return Value real Contents None","title":"ran3 – Kinematic modelling","tags":""},{"loc":"proc/start_seed.html","text":"public subroutine start_seed(idum) Arguments Type Intent Optional Attributes Name integer, intent(in) :: idum Contents None","title":"start_seed – Kinematic modelling","tags":""},{"loc":"proc/cauchy.html","text":"public subroutine cauchy(t, x) Arguments Type Intent Optional Attributes Name real, intent(in) :: t real, intent(out) :: x Contents None","title":"cauchy – Kinematic modelling","tags":""},{"loc":"proc/initial_gps.html","text":"public subroutine initial_gps(dd, aa) Load static GF and compute synthetic displacements from a fault model. Arguments Type Intent Optional Attributes Name real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) Contents None","title":"initial_gps – Kinematic modelling","tags":""},{"loc":"proc/static_synthetic.html","text":"public subroutine static_synthetic(dd, aa, nxys, err) Load static synthetic displacements from a fault model. Arguments Type Intent Optional Attributes Name real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) integer :: nxys (max_seg) real :: err Contents None","title":"static_synthetic – Kinematic modelling","tags":""},{"loc":"proc/static_remove_subfault.html","text":"public subroutine static_remove_subfault(dd, aa, n_s, n_sub) Remove static response of current subfault, for all static stations. Arguments Type Intent Optional Attributes Name real, intent(in) :: dd (nnxy,max_seg) real, intent(in) :: aa (nnxy,max_seg) integer, intent(in) :: n_s integer, intent(in) :: n_sub Contents None","title":"static_remove_subfault – Kinematic modelling","tags":""},{"loc":"proc/static_modify_subfault.html","text":"public pure subroutine static_modify_subfault(slip, rake, n_s, n_sub, err) We add the static response of the current subfault, for all static stations.\n   We compute misfit of static data Arguments Type Intent Optional Attributes Name real, intent(in) :: slip real, intent(in) :: rake integer, intent(in) :: n_s integer, intent(in) :: n_sub real, intent(out) :: err Contents None","title":"static_modify_subfault – Kinematic modelling","tags":""},{"loc":"proc/static_add_subfault.html","text":"public subroutine static_add_subfault(dd, aa, n_s, n_sub, err) Add static response of current subfault, for all stations.\n   Compute the misfit error of static data Arguments Type Intent Optional Attributes Name real, intent(in) :: dd (nnxy,max_seg) real, intent(in) :: aa (nnxy,max_seg) integer, intent(in) :: n_s integer, intent(in) :: n_sub real, intent(out) :: err Contents None","title":"static_add_subfault – Kinematic modelling","tags":""},{"loc":"proc/get_faults_data.html","text":"public subroutine get_faults_data() Read and stores in memory properties of the fault plane. Arguments None Contents None","title":"get_faults_data – Kinematic modelling","tags":""},{"loc":"proc/write_model.html","text":"public subroutine write_model(dd, aa, tt, tl, tr) Save output model to a text file. Arguments Type Intent Optional Attributes Name real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) real :: tt (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) Contents None","title":"write_model – Kinematic modelling","tags":""},{"loc":"proc/get_model_space.html","text":"public subroutine get_model_space() Define space of feasible kinematic models. Arguments None Contents None","title":"get_model_space – Kinematic modelling","tags":""},{"loc":"proc/bbsort.html","text":"public subroutine bbsort(a, mm, nn) Arguments Type Intent Optional Attributes Name real :: a (*) integer :: mm integer :: nn Contents None","title":"bbsort – Kinematic modelling","tags":""},{"loc":"proc/get_special_boundaries.html","text":"public subroutine get_special_boundaries() Arguments None Contents None","title":"get_special_boundaries – Kinematic modelling","tags":""},{"loc":"proc/subfault_positions.html","text":"public subroutine subfault_positions() We detect adjacent subfaults and their relative location Arguments None Contents None","title":"subfault_positions – Kinematic modelling","tags":""},{"loc":"proc/misfit.html","text":"public pure subroutine misfit(nf, wave_syn, error) Misfit between observed and synthetic waveforms, in wavelet domain. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf real, intent(inout) :: wave_syn (inptd) real, intent(out) :: error Contents None","title":"misfit – Kinematic modelling","tags":""},{"loc":"proc/distaz.html","text":"public subroutine distaz(lat_sta, lon_sta, lat_e, lon_e, dis, azz, baz) Arguments Type Intent Optional Attributes Name real, intent(in) :: lat_sta real, intent(in) :: lon_sta real, intent(in) :: lat_e real, intent(in) :: lon_e real(kind=8), intent(out) :: dis real(kind=8), intent(out) :: azz real(kind=8), intent(out) :: baz Contents None","title":"distaz – Kinematic modelling","tags":""},{"loc":"proc/define_slip_field.html","text":"public subroutine define_slip_field(slip, rake) Initialize slip vector field Arguments Type Intent Optional Attributes Name real, intent(in) :: slip (nnxy,max_seg) real, intent(in) :: rake (nnxy,max_seg) Contents None","title":"define_slip_field – Kinematic modelling","tags":""},{"loc":"proc/modify_slip_field.html","text":"public subroutine modify_slip_field(nn_sub, d_sub, a_sub) Modify slip vector field Arguments Type Intent Optional Attributes Name integer, intent(in) :: nn_sub real, intent(in) :: d_sub real, intent(in) :: a_sub Contents None","title":"modify_slip_field – Kinematic modelling","tags":""},{"loc":"proc/lap.html","text":"public subroutine lap(err) Laplacian regularization of slip vector field Arguments Type Intent Optional Attributes Name real, intent(out) :: err Contents None","title":"lap – Kinematic modelling","tags":""},{"loc":"proc/tlap.html","text":"public pure subroutine tlap(tt, err) Laplacian regularization of rupture initiation time Arguments Type Intent Optional Attributes Name real, intent(in) :: tt (nnxy,max_seg) real, intent(out) :: err Contents None","title":"tlap – Kinematic modelling","tags":""},{"loc":"proc/get_annealing_param.html","text":"public subroutine get_annealing_param() Arguments None Contents None","title":"get_annealing_param – Kinematic modelling","tags":""},{"loc":"proc/write_forward.html","text":"public subroutine write_forward(slip, rake, rupt_time, tl, tr, strong, cgps, body, surf, dart) We save the forward solution given a kinematic model, for all specified \n  data types. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart Contents None","title":"write_forward – Kinematic modelling","tags":""},{"loc":"proc/write_strong_motion_forward.html","text":"public subroutine write_strong_motion_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out Contents None","title":"write_strong_motion_forward – Kinematic modelling","tags":""},{"loc":"proc/write_cgps_forward.html","text":"public subroutine write_cgps_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out Contents None","title":"write_cgps_forward – Kinematic modelling","tags":""},{"loc":"proc/write_body_waves_forward.html","text":"public subroutine write_body_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out Contents None","title":"write_body_waves_forward – Kinematic modelling","tags":""},{"loc":"proc/write_surface_waves_forward.html","text":"public subroutine write_surface_waves_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out Contents None","title":"write_surface_waves_forward – Kinematic modelling","tags":""},{"loc":"proc/write_dart_forward.html","text":"public subroutine write_dart_forward(slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out Contents None","title":"write_dart_forward – Kinematic modelling","tags":""},{"loc":"proc/get_gf.html","text":"public subroutine get_gf(strong, cgps, body, surf, dart) Here, we load into memory the green functions for each subfault, for every used station Arguments Type Intent Optional Attributes Name logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart Contents None","title":"get_gf – Kinematic modelling","tags":""},{"loc":"proc/get_strong_motion_gf.html","text":"public subroutine get_strong_motion_gf(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_strong_motion_gf – Kinematic modelling","tags":""},{"loc":"proc/get_cgps_gf.html","text":"public subroutine get_cgps_gf(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_cgps_gf – Kinematic modelling","tags":""},{"loc":"proc/get_body_waves_gf.html","text":"public subroutine get_body_waves_gf(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_body_waves_gf – Kinematic modelling","tags":""},{"loc":"proc/get_surface_waves_gf.html","text":"public subroutine get_surface_waves_gf(ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_surface_waves_gf – Kinematic modelling","tags":""},{"loc":"proc/get_dart_gf.html","text":"public subroutine get_dart_gf(ll_in, ll_out) sour_sub(i) = sour_sub(i)+cmplx(cos(a), sin(a)) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out Contents None","title":"get_dart_gf – Kinematic modelling","tags":""},{"loc":"proc/deallocate_gf.html","text":"public subroutine deallocate_gf() Arguments None Contents None","title":"deallocate_gf – Kinematic modelling","tags":""},{"loc":"proc/n_threads.html","text":"public subroutine n_threads(auto) Uses omp_lib Arguments Type Intent Optional Attributes Name logical :: auto Contents None","title":"n_threads – Kinematic modelling","tags":""},{"loc":"proc/initial_model.html","text":"public subroutine initial_model(slip, rake, rupt_time, tl, tr) We define initial model for the annealing method. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) Contents None","title":"initial_model – Kinematic modelling","tags":""},{"loc":"proc/initial_regularization.html","text":"public subroutine initial_regularization(slip, rake, rupt_time, tl, tr, static) We compute regularization coefficients, and store them in memory. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) logical :: static Contents None","title":"initial_regularization – Kinematic modelling","tags":""},{"loc":"proc/annealing_iter.html","text":"public subroutine annealing_iter(slip, rake, rupt_time, tl, tr, er, t) We compute an iteration of the annealing method.\n  Non-parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t Contents None","title":"annealing_iter – Kinematic modelling","tags":""},{"loc":"proc/annealing_iter2.html","text":"public subroutine annealing_iter2(slip, rake, rupt_time, tl, tr, er, t) We compute an iteration of the annealing method, adding static GPS data.\n  Non-parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t Contents None","title":"annealing_iter2 – Kinematic modelling","tags":""},{"loc":"proc/annealing_iter3.html","text":"public subroutine annealing_iter3(slip, rake, rupt_time, tl, tr, er, t) Uses omp_lib We compute an iteration of the annealing method.\n  Parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t Contents None","title":"annealing_iter3 – Kinematic modelling","tags":""},{"loc":"proc/annealing_iter4.html","text":"public subroutine annealing_iter4(slip, rake, rupt_time, tl, tr, er, t) Uses omp_lib We compute an iteration of the annealing method, adding static GPS data.\n  Parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t Contents None","title":"annealing_iter4 – Kinematic modelling","tags":""},{"loc":"proc/rad_coef.html","text":"public subroutine rad_coef(dip, theta, az, ang_d, coef_v, coef_r) Eight Green´s function in the sequence SS DS SS DS DD SS DS DD Arguments Type Intent Optional Attributes Name real(kind=8) :: dip real(kind=8) :: theta real(kind=8) :: az real(kind=8) :: ang_d real(kind=8) :: coef_v (2,3) real(kind=8) :: coef_r (2,5) Contents None","title":"rad_coef – Kinematic modelling","tags":""},{"loc":"module/rise_time.html","text":"Uses constants get_stations_data model_parameters Contents Variables source Subroutines realtr fft fourier_asym_cosine get_source_fun deallocate_source Variables Type Visibility Attributes Name Initial complex, public, allocatable :: source (:,:,:,:) Subroutines public subroutine realtr (xr, xi, n) Arguments Type Intent Optional Attributes Name real :: xr (*) real :: xi (*) integer :: n public subroutine fft (xr, xi, n, sn) Fast Fourier transform. Arguments Type Intent Optional Attributes Name real :: xr (*) real :: xi (*) integer :: n real :: sn public subroutine fourier_asym_cosine (omega, t1, t2, source) Analitic fourier transform of asymmetric cosine Arguments Type Intent Optional Attributes Name real :: omega real :: t1 real :: t2 complex :: source public subroutine get_source_fun () We load to memory, the Fourier transform of rise time function Arguments None public subroutine deallocate_source () Arguments None","title":"rise_time – Kinematic modelling","tags":""},{"loc":"module/retrieve_surf_gf.html","text":"Uses constants Contents Variables npt_bank dt_bank Functions interp_gf Subroutines get_surf_gf_data get_surf_gf grid_properties get_subgrid_bounds get_subgrid Variables Type Visibility Attributes Name Initial integer, public :: npt_bank integer, public :: dt_bank Functions public function interp_gf (distance, depth, d_min, d_max, zu_min, zu_max) result(green_out) Get GF at a given location and depth, as the average of the 4 closest\n  GF in the distance-depth grid. Arguments Type Intent Optional Attributes Name real(kind=8) :: distance real :: depth real :: d_min real :: d_max real :: zu_min real :: zu_max Return Value complex\n  (inptd,10) Subroutines public subroutine get_surf_gf_data (gf_file, gf_bank) Arguments Type Intent Optional Attributes Name character(len=100), intent(in) :: gf_file character(len=100), intent(out) :: gf_bank public subroutine get_surf_gf (gf_bank, d_min, d_max, z_min, z_max) Load to memory GF bank, from a specified location. Arguments Type Intent Optional Attributes Name character(len=100) :: gf_bank real :: d_min real :: d_max real :: z_min real :: z_max public subroutine grid_properties () Arguments None public subroutine get_subgrid_bounds (fault_bounds, nx_b, nx_e, nz_b, nz_e) Arguments Type Intent Optional Attributes Name real, intent(in) :: fault_bounds (2,2) integer, intent(out) :: nx_b integer, intent(out) :: nx_e integer, intent(out) :: nz_b integer, intent(out) :: nz_e public subroutine get_subgrid (fault_bounds, subgrid_dist, subgrid_depth) Arguments Type Intent Optional Attributes Name real, intent(in) :: fault_bounds (2,2) real, intent(out) :: subgrid_dist (1601) real, intent(out) :: subgrid_depth (20)","title":"retrieve_surf_gf – Kinematic modelling","tags":""},{"loc":"module/constants.html","text":"Contents Variables nnpy nnpx nnxs nnys mmsou mpx mpy nnxy nnpxy l2 npth inptd n_data nnsta max_seg nnxy_m nt1 npuse block_stg block_far ltde pi twopi dpi pi_0 twopi_0 dpi_0 nlay ndis nt nny Variables Type Visibility Attributes Name Initial integer, public, parameter :: nnpy = 25 integer, public, parameter :: nnpx = 25 integer, public, parameter :: nnxs = 50 integer, public, parameter :: nnys = 20 integer, public, parameter :: mmsou = 25 integer, public, parameter :: mpx = nnpx*nnxs integer, public, parameter :: mpy = nnpy*nnys integer, public, parameter :: nnxy = nnxs*nnys integer, public, parameter :: nnpxy = nnpx*nnpy integer, public, parameter :: l2 = 10 integer, public, parameter :: npth = 2**l2 integer, public, parameter :: inptd = 2*npth integer, public, parameter :: n_data = 10000 integer, public, parameter :: nnsta = 300 integer, public, parameter :: max_seg = 5 integer, public, parameter :: nnxy_m = 660 integer, public, parameter :: nt1 = max_seg*nnxy_m integer, public, parameter :: npuse = 513 integer, public, parameter :: block_stg = npuse*130 integer, public, parameter :: block_far = 256*1024 integer, public, parameter :: ltde = 320000 real(kind=8), public, parameter :: pi = 4.d0*atan(1.d0) real(kind=8), public, parameter :: twopi = 2.d0*pi real(kind=8), public, parameter :: dpi = pi/180.d0 real, public, parameter :: pi_0 = 4.0*atan(1.0) real, public, parameter :: twopi_0 = 2.0*pi_0 real, public, parameter :: dpi_0 = pi_0/180.0 integer, public, parameter :: nlay = 50 integer, public, parameter :: ndis = 1100 integer, public, parameter :: nt = 1025 integer, public, parameter :: nny = 310","title":"constants – Kinematic modelling","tags":""},{"loc":"module/wavelets.html","text":"Uses constants wavelet_param Contents Variables rwt1 rwt2 c1 c2 kkk cos_fft sin_fft Functions wave Subroutines wavelet_obs wavelet_syn cfft cifft fourier_coefs meyer_yamada realtr Variables Type Visibility Attributes Name Initial complex, public :: rwt1 (inptd,12) complex, public :: rwt2 (inptd,12) complex, public :: c1 complex, public :: c2 integer, public :: kkk (4200,15) real, public :: cos_fft (4200,15) real, public :: sin_fft (4200,15) Functions public function wave (w, ic) result(wave1) Meyer wavelet function in frequency domain. Arguments Type Intent Optional Attributes Name real(kind=8) :: w integer :: ic Return Value complex Subroutines public subroutine wavelet_obs (cr, cz, u) Compute wavelet transform. Input data is in time domain Arguments Type Intent Optional Attributes Name real :: cr (inptd) real :: cz (inptd) real :: u (inptd) public pure subroutine wavelet_syn (cr, cz, u) Compute wavelet transform. Input data is in frequency domain Arguments Type Intent Optional Attributes Name real, intent(inout) :: cr (inptd) real, intent(inout) :: cz (inptd) real, intent(out) :: u (inptd) public pure subroutine cfft (xr, xi, n) Fast Fourier transform Arguments Type Intent Optional Attributes Name real, intent(inout) :: xr (*) real, intent(inout) :: xi (*) integer, intent(in) :: n public pure subroutine cifft (xr, xi, n) Inverse Fast Fourier transform Arguments Type Intent Optional Attributes Name real, intent(inout) :: xr (*) real, intent(inout) :: xi (*) integer, intent(in) :: n public subroutine fourier_coefs () We load into memory certain values of sine and cosine, frequently used in computing the\n  Fast Fourier Transform. Arguments None public subroutine meyer_yamada () We load into memory the values of the Meyer wavelet function, \n   which are used when computing the wavelet transform of an input data. Arguments None public subroutine realtr (xr, xi, n) Arguments Type Intent Optional Attributes Name real :: xr (*) real :: xi (*) integer :: n","title":"wavelets – Kinematic modelling","tags":""},{"loc":"module/get_stations_data.html","text":"Uses constants wavelet_param wavelets Contents Variables nnsta_tele weight wave_obs wmax dt_channel misfit_type t_max t_max_val wavelet_weight Subroutines get_data get_strong_motion_stations get_cgps_stations get_body_waves_stations get_surface_waves_stations get_dart_stations Variables Type Visibility Attributes Name Initial integer, public, parameter :: nnsta_tele = 80 real, public :: weight (nnsta) real, public :: wave_obs (npth,nnsta) real, public :: wmax (nnsta) real, public :: dt_channel (nnsta) integer, public :: misfit_type (12,nnsta) integer, public :: t_max (nnsta) integer, public :: t_max_val (nnsta) real, public :: wavelet_weight (12,nnsta) Subroutines public subroutine get_data (strong, cgps, body, surf, dart) We load into memory, wavelet transform of observed data, and \n  other properties of stations Arguments Type Intent Optional Attributes Name logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart public subroutine get_strong_motion_stations (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_cgps_stations (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_body_waves_stations (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_surface_waves_stations (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_dart_stations (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out","title":"get_stations_data – Kinematic modelling","tags":""},{"loc":"module/random_gen.html","text":"Contents Variables iv iy iff inext inextp ma seed Functions ran1 ran3 Subroutines start_seed cauchy Variables Type Visibility Attributes Name Initial integer, public :: iv (ntab) integer, public :: iy integer, public :: iff integer, public :: inext integer, public :: inextp integer, public :: ma (55) integer, public :: seed Functions public function ran1 () result(random) Arguments None Return Value real public function ran3 () result(random) *  routine to generate a uniformly distributed random *  number on the interval [0, 1]. Arguments None Return Value real Subroutines public subroutine start_seed (idum) Arguments Type Intent Optional Attributes Name integer, intent(in) :: idum public subroutine cauchy (t, x) Arguments Type Intent Optional Attributes Name real, intent(in) :: t real, intent(out) :: x","title":"random_gen – Kinematic modelling","tags":""},{"loc":"module/static_data.html","text":"Uses constants model_parameters Contents Variables n_chan synm_whole weight_sum lat lon green syn_disp obse weight sta_name Subroutines initial_gps static_synthetic static_remove_subfault static_modify_subfault static_add_subfault Variables Type Visibility Attributes Name Initial integer, public :: n_chan real(kind=8), public :: synm_whole (n_stations,3) real(kind=8), public :: weight_sum real, public :: lat (n_stations) real, public :: lon (n_stations) real, public :: green (n_stations,6,nnxy,max_seg) real, public :: syn_disp (n_stations,3) real, public :: obse (n_stations,3) real, public :: weight (n_stations,3) character(len=6), public :: sta_name (n_stations) Subroutines public subroutine initial_gps (dd, aa) Load static GF and compute synthetic displacements from a fault model. Arguments Type Intent Optional Attributes Name real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) public subroutine static_synthetic (dd, aa, nxys, err) Load static synthetic displacements from a fault model. Arguments Type Intent Optional Attributes Name real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) integer :: nxys (max_seg) real :: err public subroutine static_remove_subfault (dd, aa, n_s, n_sub) Remove static response of current subfault, for all static stations. Arguments Type Intent Optional Attributes Name real, intent(in) :: dd (nnxy,max_seg) real, intent(in) :: aa (nnxy,max_seg) integer, intent(in) :: n_s integer, intent(in) :: n_sub public pure subroutine static_modify_subfault (slip, rake, n_s, n_sub, err) We add the static response of the current subfault, for all static stations.\n   We compute misfit of static data Arguments Type Intent Optional Attributes Name real, intent(in) :: slip real, intent(in) :: rake integer, intent(in) :: n_s integer, intent(in) :: n_sub real, intent(out) :: err public subroutine static_add_subfault (dd, aa, n_s, n_sub, err) Add static response of current subfault, for all stations.\n   Compute the misfit error of static data Arguments Type Intent Optional Attributes Name real, intent(in) :: dd (nnxy,max_seg) real, intent(in) :: aa (nnxy,max_seg) integer, intent(in) :: n_s integer, intent(in) :: n_sub real, intent(out) :: err","title":"static_data – Kinematic modelling","tags":""},{"loc":"module/wavelet_param.html","text":"Contents Variables lnpt nlen jmin jmax jfmax Variables Type Visibility Attributes Name Initial integer, public :: lnpt integer, public :: nlen integer, public :: jmin integer, public :: jmax integer, public :: jfmax","title":"wavelet_param – Kinematic modelling","tags":""},{"loc":"module/model_parameters.html","text":"Uses constants modelling_inputs Contents Variables slip0 rake0 rupt_time0 tl0 tr0 n_seg nxs_sub nys_sub nx_p ny_p nxs0 nys0 dip_seg stk_seg delay_seg point_sources cniu c_depth dxs dys v_ref v_min v_max tbl tbr ta0 dta time_min time_max rake_min msou jfmax beg dp np nleft nright nup ndown Subroutines get_faults_data write_model get_model_space bbsort get_special_boundaries subfault_positions Variables Type Visibility Attributes Name Initial real, public :: slip0 (nnxy,max_seg) real, public :: rake0 (nnxy,max_seg) real, public :: rupt_time0 (nnxy,max_seg) real, public :: tl0 (nnxy,max_seg) real, public :: tr0 (nnxy,max_seg) integer, public :: n_seg integer, public :: nxs_sub (max_seg) integer, public :: nys_sub (max_seg) integer, public :: nx_p integer, public :: ny_p integer, public :: nxs0 integer, public :: nys0 real, public :: dip_seg (max_seg) real, public :: stk_seg (max_seg) real, public :: delay_seg (max_seg) real, public :: point_sources (7,nnpx,nnpy,nnxs,nnys,max_seg) real, public :: cniu (nnxy,max_seg) real, public :: c_depth real, public :: dxs real, public :: dys real, public :: v_ref real, public :: v_min real, public :: v_max real, public :: tbl real, public :: tbr real, public :: ta0 real, public :: dta real, public :: time_min (nnxy,max_seg) real, public :: time_max (nnxy,max_seg) real, public :: rake_min integer, public :: msou integer, public :: jfmax real, public :: beg (nt1) real, public :: dp (nt1) integer, public :: np (nt1) integer, public :: nleft (3,nnys,nnxs,max_seg) integer, public :: nright (3,nnys,nnxs,max_seg) integer, public :: nup (3,nnys,nnxs,max_seg) integer, public :: ndown (3,nnys,nnxs,max_seg) Subroutines public subroutine get_faults_data () Read and stores in memory properties of the fault plane. Arguments None public subroutine write_model (dd, aa, tt, tl, tr) Save output model to a text file. Arguments Type Intent Optional Attributes Name real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) real :: tt (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) public subroutine get_model_space () Define space of feasible kinematic models. Arguments None public subroutine bbsort (a, mm, nn) Arguments Type Intent Optional Attributes Name real :: a (*) integer :: mm integer :: nn public subroutine get_special_boundaries () Arguments None public subroutine subfault_positions () We detect adjacent subfaults and their relative location Arguments None","title":"model_parameters – Kinematic modelling","tags":""},{"loc":"module/misfit_eval.html","text":"Uses constants wavelet_param get_stations_data Contents Subroutines misfit Subroutines public pure subroutine misfit (nf, wave_syn, error) Misfit between observed and synthetic waveforms, in wavelet domain. Arguments Type Intent Optional Attributes Name integer, intent(in) :: nf real, intent(inout) :: wave_syn (inptd) real, intent(out) :: error","title":"misfit_eval – Kinematic modelling","tags":""},{"loc":"module/geodesics.html","text":"Uses constants Contents Subroutines distaz Subroutines public subroutine distaz (lat_sta, lon_sta, lat_e, lon_e, dis, azz, baz) Arguments Type Intent Optional Attributes Name real, intent(in) :: lat_sta real, intent(in) :: lon_sta real, intent(in) :: lat_e real, intent(in) :: lon_e real(kind=8), intent(out) :: dis real(kind=8), intent(out) :: azz real(kind=8), intent(out) :: baz","title":"geodesics – Kinematic modelling","tags":""},{"loc":"module/regularization.html","text":"Uses constants model_parameters Contents Variables slip_field nnn nxys Subroutines define_slip_field modify_slip_field lap tlap Variables Type Visibility Attributes Name Initial real, public :: slip_field (nnxy,max_seg,2) integer, public :: nnn integer, public :: nxys (max_seg) Subroutines public subroutine define_slip_field (slip, rake) Initialize slip vector field Arguments Type Intent Optional Attributes Name real, intent(in) :: slip (nnxy,max_seg) real, intent(in) :: rake (nnxy,max_seg) public subroutine modify_slip_field (nn_sub, d_sub, a_sub) Modify slip vector field Arguments Type Intent Optional Attributes Name integer, intent(in) :: nn_sub real, intent(in) :: d_sub real, intent(in) :: a_sub public subroutine lap (err) Laplacian regularization of slip vector field Arguments Type Intent Optional Attributes Name real, intent(out) :: err public pure subroutine tlap (tt, err) Laplacian regularization of rupture initiation time Arguments Type Intent Optional Attributes Name real, intent(in) :: tt (nnxy,max_seg) real, intent(out) :: err","title":"regularization – Kinematic modelling","tags":""},{"loc":"module/modelling_inputs.html","text":"Contents Variables idum io_data n_iter t0 cooling_rate t_stop emin smooth_moment smooth_slip smooth_time t_mid t_latest cm_point io_re io_func io Subroutines get_annealing_param Variables Type Visibility Attributes Name Initial integer, public :: idum integer, public :: io_data integer, public :: n_iter real, public :: t0 real, public :: cooling_rate real, public :: t_stop real, public :: emin real, public :: smooth_moment real, public :: smooth_slip real, public :: smooth_time real, public :: t_mid real, public :: t_latest real, public :: cm_point integer, public :: io_re integer, public :: io_func integer, public :: io Subroutines public subroutine get_annealing_param () Arguments None","title":"modelling_inputs – Kinematic modelling","tags":""},{"loc":"module/save_forward.html","text":"Uses constants model_parameters wavelet_param get_stations_data retrieve_gf rise_time modelling_inputs Contents Variables nnsta_tele Subroutines write_forward write_strong_motion_forward write_cgps_forward write_body_waves_forward write_surface_waves_forward write_dart_forward Variables Type Visibility Attributes Name Initial integer, public, parameter :: nnsta_tele = 80 Subroutines public subroutine write_forward (slip, rake, rupt_time, tl, tr, strong, cgps, body, surf, dart) We save the forward solution given a kinematic model, for all specified \n  data types. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart public subroutine write_strong_motion_forward (slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out public subroutine write_cgps_forward (slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out public subroutine write_body_waves_forward (slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out public subroutine write_surface_waves_forward (slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out public subroutine write_dart_forward (slip, rake, rupt_time, tl, tr, ll_in, ll_out) Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) integer :: ll_in integer :: ll_out","title":"save_forward – Kinematic modelling","tags":""},{"loc":"module/retrieve_gf.html","text":"Uses constants model_parameters wavelets retrieve_surf_gf rad_pattern geodesics rise_time Contents Variables nnsta_tele green_dip green_stk Subroutines get_gf get_strong_motion_gf get_cgps_gf get_body_waves_gf get_surface_waves_gf get_dart_gf deallocate_gf Variables Type Visibility Attributes Name Initial integer, public, parameter :: nnsta_tele = 80 complex, public, allocatable :: green_dip (:,:,:) complex, public, allocatable :: green_stk (:,:,:) Subroutines public subroutine get_gf (strong, cgps, body, surf, dart) Here, we load into memory the green functions for each subfault, for every used station Arguments Type Intent Optional Attributes Name logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart public subroutine get_strong_motion_gf (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_cgps_gf (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_body_waves_gf (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_surface_waves_gf (ll_in, ll_out) Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine get_dart_gf (ll_in, ll_out) Read more… Arguments Type Intent Optional Attributes Name integer :: ll_in integer :: ll_out public subroutine deallocate_gf () Arguments None","title":"retrieve_gf – Kinematic modelling","tags":""},{"loc":"module/annealing.html","text":"Uses constants retrieve_gf wavelets wavelet_param rise_time get_stations_data random_gen misfit_eval modelling_inputs model_parameters regularization static_data Contents Variables coef_moment coef_slip coef_st coef_time emin ermin min_dt area n_chan nxys nnn double Subroutines n_threads initial_model initial_regularization annealing_iter annealing_iter2 annealing_iter3 annealing_iter4 Variables Type Visibility Attributes Name Initial real, public :: coef_moment real, public :: coef_slip real, public :: coef_st real, public :: coef_time real, public :: emin real, public :: ermin real, public :: min_dt real, public :: area integer, public :: n_chan integer, public :: nxys (max_seg) integer, public :: nnn integer, public, parameter :: double = kind(1.d0) Subroutines public subroutine n_threads (auto) Arguments Type Intent Optional Attributes Name logical :: auto public subroutine initial_model (slip, rake, rupt_time, tl, tr) We define initial model for the annealing method. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) public subroutine initial_regularization (slip, rake, rupt_time, tl, tr, static) We compute regularization coefficients, and store them in memory. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) logical :: static public subroutine annealing_iter (slip, rake, rupt_time, tl, tr, er, t) We compute an iteration of the annealing method.\n  Non-parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t public subroutine annealing_iter2 (slip, rake, rupt_time, tl, tr, er, t) We compute an iteration of the annealing method, adding static GPS data.\n  Non-parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t public subroutine annealing_iter3 (slip, rake, rupt_time, tl, tr, er, t) We compute an iteration of the annealing method.\n  Parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t public subroutine annealing_iter4 (slip, rake, rupt_time, tl, tr, er, t) We compute an iteration of the annealing method, adding static GPS data.\n  Parallelized version. Arguments Type Intent Optional Attributes Name real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t","title":"annealing – Kinematic modelling","tags":""},{"loc":"module/rad_pattern.html","text":"Uses constants Contents Subroutines rad_coef Subroutines public subroutine rad_coef (dip, theta, az, ang_d, coef_v, coef_r) Eight Green´s function in the sequence SS DS SS DS DD SS DS DD Arguments Type Intent Optional Attributes Name real(kind=8) :: dip real(kind=8) :: theta real(kind=8) :: az real(kind=8) :: ang_d real(kind=8) :: coef_v (2,3) real(kind=8) :: coef_r (2,5)","title":"rad_pattern – Kinematic modelling","tags":""},{"loc":"program/run_modelling.html","text":"Uses constants model_parameters modelling_inputs get_stations_data retrieve_gf save_forward rise_time static_data random_gen annealing Contents Variables i slip rake rupt_time tl tr er t static strong cgps dart body surf auto input Variables Type Attributes Name Initial integer :: i real :: slip (nnxy,max_seg) real :: rake (nnxy,max_seg) real :: rupt_time (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t logical :: static logical :: strong logical :: cgps logical :: dart logical :: body logical :: surf logical :: auto character(len=10) :: input","title":"run_modelling – Kinematic modelling","tags":""},{"loc":"program/run_modelling~2.html","text":"Uses constants model_parameters modelling_inputs get_stations_data retrieve_gf save_forward rise_time annealing Contents Variables io_data2 i dd aa tt tl tr er t Variables Type Attributes Name Initial integer :: io_data2 integer :: i real :: dd (nnxy,max_seg) real :: aa (nnxy,max_seg) real :: tt (nnxy,max_seg) real :: tl (nnxy,max_seg) real :: tr (nnxy,max_seg) real :: er real :: t","title":"run_modelling – Kinematic modelling","tags":""},{"loc":"program/run_forward.html","text":"Uses constants model_parameters modelling_inputs get_stations_data retrieve_gf save_forward static_data Contents Variables i input static strong cgps body surf dart Variables Type Attributes Name Initial integer :: i character(len=10) :: input logical :: static logical :: strong logical :: cgps logical :: body logical :: surf logical :: dart","title":"run_forward – Kinematic modelling","tags":""}]}